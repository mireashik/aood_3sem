## АЛГОРИТМЫ ПОИСКА МИНИМАЛЬНОГО ОСТОВНОГО ДЕРЕВА
### 1.1. Остовное дерево

![image](https://github.com/mireashik/aood_3sem/assets/49165758/14b57cb0-8d96-4fe7-a766-713f134bd015)

Минимальное остовного дерева ‒ остовного дерева с минимальным возможным весом

![image](https://github.com/mireashik/aood_3sem/assets/49165758/7ba3eb37-909c-4ec6-b710-1b751330e869)

1. Минимальный остов **УНИКАЛЕН**, если веса всех рёбер различны (иначе может существовать несколько минимальных остовов)
2. Минимальный остов является также и остовом с минимальным **произведением** весов рёбер
3. Минимальный остов является также и остовом с минимальным весом самого **тяжелого** ребра
4. Остов **МАКСИМАЛЬНОГО** веса ищется аналогично остову МИНИМАЛЬНОГО веса,

На задачу о нахождении минимального остовного дерева похожа ЗАДАЧА о **дереве Штейнера** - несколько точек на плоскости с мин. суммой длин путей (однако там разрешается добавлять дополнительные точки ветвления)

Типичное применение остовных деревьев минимальной стоимости можно найти при разработке коммуникационных сетей

Для нахождения минимального остовного дерева графа существуют 4 алгоритма:
- Алгоритм Прима (нередко в литературе встречается название этого алгоритма – **алгоритм Дейкстры-Прима**)
- Алгоритм Краскала (или алгоритм Крускала)
- Алгоритм Борувки
- Алгоритм обратного удаления (получение минимального остовного  дерева из связного рёберно взвешенного графа)

алгоритм Прима и алгоритм Крускала частные случаи алгоритма Борувки, все они для **неориентированных** графов

### 1.2. Расширение кругозора
### 1.2.1. Жадный алгоритм
Перед тем как рассмотреть алгоритмы поиска минимального остовного дерева, рассмотрим жадный алгоритм. 

Чтобы не стрелять наугад и не искать лучший выбор, в **ЖАДНОМ** алгоритме выбирается лучший выбор на **текущий** момент. И мы надеемся что этот **локальный** выбор приведёт глобально к лучшему.
<br>
**Жадные** алгоритмы **не всегда** приводят к оптимальному решению, но во многих задачах они дают нужный результат.

1. жадный выбор на первом шаге не закрывает пути к оптимальному решению
2. подзадача на первом шаге аналогична исходной

**Оптимальное решение задачи** - это оптимальные решения для всех её подзадач.

### 1.2.2. Динамическое программирование
**Алгоритм Флойда** (мин. путь между всеми вершинами) - не жадный алгоритм, он использует динамическое программирование.
