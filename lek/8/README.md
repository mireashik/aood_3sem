## АЛГОРИТМЫ ПОИСКА МИНИМАЛЬНОГО ОСТОВНОГО ДЕРЕВА
## 1.1. Остовное дерево

![image](https://github.com/mireashik/aood_3sem/assets/49165758/14b57cb0-8d96-4fe7-a766-713f134bd015)

Минимальное остовного дерева ‒ остовного дерева с минимальным возможным весом

![image](https://github.com/mireashik/aood_3sem/assets/49165758/7ba3eb37-909c-4ec6-b710-1b751330e869)

1. Минимальный остов **УНИКАЛЕН**, если веса всех рёбер различны (иначе может существовать несколько минимальных остовов)
2. Минимальный остов является также и остовом с минимальным **произведением** весов рёбер
3. Минимальный остов является также и остовом с минимальным весом самого **тяжелого** ребра
4. Остов **МАКСИМАЛЬНОГО** веса ищется аналогично остову МИНИМАЛЬНОГО веса,

На задачу о нахождении минимального остовного дерева похожа ЗАДАЧА о **дереве Штейнера** - несколько точек на плоскости с мин. суммой длин путей (однако там разрешается добавлять дополнительные точки ветвления)

Типичное применение остовных деревьев минимальной стоимости можно найти при разработке коммуникационных сетей

Для нахождения минимального остовного дерева графа существуют 4 алгоритма:
- Алгоритм Прима (нередко в литературе встречается название этого алгоритма – **алгоритм Дейкстры-Прима**)
- Алгоритм Краскала (или алгоритм Крускала)
- Алгоритм Борувки
- Алгоритм обратного удаления (получение минимального остовного  дерева из связного рёберно взвешенного графа)

алгоритм Прима и алгоритм Крускала частные случаи алгоритма Борувки, все они для **неориентированных** графов

### 1.2. Расширение кругозора
### 1.2.1. Жадный алгоритм
Перед тем как рассмотреть алгоритмы поиска минимального остовного дерева, рассмотрим жадный алгоритм. 

Чтобы не стрелять наугад и не искать лучший выбор, в **ЖАДНОМ** алгоритме выбирается лучший выбор на **текущий** момент. И мы надеемся что этот **локальный** выбор приведёт глобально к лучшему.
<br>
**Жадные** алгоритмы **не всегда** приводят к оптимальному решению, но во многих задачах они дают нужный результат.

1. жадный выбор на первом шаге не закрывает пути к оптимальному решению
2. подзадача на первом шаге аналогична исходной

**Оптимальное решение задачи** - это оптимальные решения для всех её подзадач.

### 1.2.2. Динамическое программирование
**Алгоритм Флойда** (мин. путь между всеми вершинами) - не жадный алгоритм, он использует динамическое программирование.
<br>
Динамическое программирование - решение сложной задачи путём разбиения их на более простые подзадачи

Метод программирования сверху ‒ запоминание результатов подзадач, которые могут повторно встретиться далее
<br>
Метод программирования снизу - переформулирование сложной задачи в виде рекурсии более простых подзадач

## 1.3. Алгоритм Дейкстры-Прима
### 1.3.1. Описание алгоритма
Каждый шаг - выбираем из множества рёбер, ребро с минимальным весом

Разобьем вершины графа на 3 класса: 
- ВЕРШИНЫ, вошедшие в уже построенную часть дерева
- ВЕРШИНЫ, окаймляющие построенную часть
- ВЕРШИНЫ еще не рассмотренные

Начнем с произвольной вершины графа и включим ее в остовное дерево (выбор исходной вершины не влияет на результат)
<br>
Все вершины, соединенные с данной, заносим в **КАЙМУ**
<br>
Цикл поиска ребра с наименьшим весом
<br>
Это ребро вместе с новой вершиной добавляется в дерево и происходит обновление КАЙМЫ

Допустим начальная вершина будет А:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/ab9d0362-1a46-4fe6-98c9-e050b67f9ea1)

Все вершины, непосредственно связанные с А:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/6f173c66-4c4a-4983-b493-6f6cd0979a16)

Миниальное ребро с B, добавляем его в кайму:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/34985588-61ee-44f3-9dea-9cdb3d5dc9ff)

Из 5 рёбер минимальный вес BE (3):

![image](https://github.com/mireashik/aood_3sem/assets/49165758/940d78a2-1272-4ad4-b731-fabd0b4fff82)

Теперь смотрим вершину А, там минимальный вес 4:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/044969a1-5b40-4846-84ec-e3a97566c246)

Далее вершина F:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/d6fe5c1a-eb9d-47ba-812f-cd063fc5ed41)

Добавляем вершину D:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/4b51e163-c4ab-4032-a5ea-5e14e31fe534)

Осталось одна вершина G:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/7094034a-1e03-404d-9a89-d96c8d9a2491)
