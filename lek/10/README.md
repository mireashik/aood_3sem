### СОРТИРОВКА: ОБЩИЕ ПОНЯТИЯ И ОПРЕДЕЛЕНИЯ
мы должны хранить ее в каком-то разумном порядке. Библиотекари следят за тем, чтобы никто не перекладывал книги. Кредитные организации следят за каждым нашим шагом.
<br>
Имена потребуется отсортировать по алфавиту, студентов ‒ по среднему баллу, клиентов ‒ по регионам, данные о продажах ‒ по ценам, города ‒ по населению, страны ‒ по ВВП и т.д

Мы рассмотрим алгоритмы, относящиеся к ПРОСТОЙ СОРТИРОВКЕ.
<br>
Далее мы рассмотрим алгоритмы УЛУЧШЕННОЙ СОРТИРОВКИ, или, алгоритмы сложной сортировки, как нередко их называют

Простые алгоритмы, работают относительно медленно и все же их стоит изучить.
<br>
Сортировка **методом вставки** превосходит **быструю сортировку** для небольших и почти отсортированных файлов

![image](https://github.com/mireashik/aood_3sem/assets/49165758/ace4dc1c-eacd-4f63-8933-32bf5c798704)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/18b68d01-5eec-49ab-acc9-39a0581a79bf)

1. Сравнить два элемента.
2. Поменять элементы местами или скопировать один из них.

Цель сортировки ‒ облегчение последующего поиска элементов в отсортированном множестве во внутренней или внешней памяти. 

Одно из полей, называемое КЛЮЧОМ, имеет такой тип данных, что на нем определено отношение линейного порядка «<».

![image](https://github.com/mireashik/aood_3sem/assets/49165758/67e2c8e5-a63c-4f76-ac51-be0e0f044255)

Сортировать можно массивы, связанные списки, строки

Кол-во алгоритмов приближается к 40 (и даже уже превышает 40, а с модификациями ещё больше – около 42-44, скорее всего и эти цифры заниженные).

Все эти алгоритмы можно классифицировать:
- внутренней;
- внешней.

**Алгоритмы внутренней сортировки** (сортировки массивов) предназначены для  работы с данными, которые **полностью** помещаются в оперативную память  вычислительной машины, выполняющей данную операцию. 
<br>
Важна экономичность по памяти

![image](https://github.com/mireashik/aood_3sem/assets/49165758/32df0c33-d708-4fc7-9395-4d606e4bb952)

**Алгоритмы внешней сортировки** (сортировки файлов) предназначены для работы с данными, объем которых **не позволяет** полностью разместить их в оперативной памяти вычислительной машины, выполняющей данную операцию (диски и магнитные ленты)

Основной метод сортировки – слияние.

- доступ к носителю осуществляется **последовательным** образом
- в каждый момент времени можно считать или записать только **1 элемент**
- доступ к данным на носителе производится намного **медленнее**, чем с ОЗУ

В зависимости от структуры:
- массива
- связного списка
- дерева (пирамиды)
- графа

Как структура меняется:
- сортировка списка (если элементы перемещаются)
- сортировка таблицы адресов (если элементы не перемещаются, таблица адресов)

Функциональные особенности:
- сортировка перестановками (обменная) – пузырьковая сортировка
- сортировка выбором (отбором)
- сортировка вставками
- сортировка подсчетом
- сортировка слиянием
- распределяющая сортировка

По широте применения:
- универсальные (большинство перечисленных выше групп алгоритмов)
- не универсальные (для конкретных случаев)

По перестановки совпадающих данных:
- УСТОЙЧИВЫМИ (не меняющие порядок)
- НЕУСТОЙЧИВЫЕ (меняющие порядок)

По времени работы:
- $O(N^2)$ - N-квадратичные
- $O(N^k)$ - где 1<k<2, алгоритм Шелла, если $k=3$ - глупая сортировка
- $O(log_2N)$ − логарифмические (быстрая сортировка, сортировка слиянием и пирамидальная сортировка)
- $O(N)$ – алгоритмы, требующие линейного времени, например, «блинная» сортировка

Возможны также некоторые другие принципы разделения алгоритмов сортировки, в том числе по занимаемой дополнительной памяти.

Оценка алгоритмов сортировки производится по следующим параметрам:
- ВРЕМЯ СОРТИРОВКИ
- количество шагов алгоритма
- количество сравнений между значениями ключей
- ПАМЯТЬ
- УСТОЙЧИВОСТЬ
- ЕСТЕСТВЕННОСТЬ ПОВЕДЕНИЯ (при уже отсортированных или частично отсортированных данных)

- ЛУЧШИЙ случай − это ситуация, когда структура данных уже **отсортирована** в нужном порядке.
- ХУДШИЙ случай – структура данных отсортирована в порядке, обратном  требуемому.

## АЛГОРИТМЫ СОРТИРОВКИ
### 2.1. Задача сортировки
![image](https://github.com/mireashik/aood_3sem/assets/49165758/91c255f9-2ef9-4a97-8176-d78b82d19293)

Пусть ключом будет число жителей. Мы можем упорядочить эту последовательность несколькими способами, так как у нас есть одинаковые ключи. 

### 2.1.1 Устойчивость сортировки
Алгоритм сортировки устойчивый, если он сохраняет относительный порядок элементов с одинаковыми ключами (при наличии одинаковых ключей)

### 2.2 Сортировка сравнением
Один из популярных способов ‒ просто сравнить эти два элемента

### 2.2.1 Понятие инверсии
Инверсия ‒ пара ключей с нарушенным порядком следования.

### 2.2.2 Индуктивные функции и инварианты
Предикат ‒ логическое утверждение, содержащее переменную величину.
<br>
Инвариант ‒ предикат, сохраняющий своё значение после исполнения заданных шагов алгоритма.

### 2.2.3 Пузырьковая сортировка (Bubble-sort)
Сортировка пузырьком (обменная сортировка) – простой в реализации и малоэффективный алгоритм сортировки.
<br>
Повторяющиеся проходы

![gif](https://habrastorage.org/getpro/habr/post_images/187/5a3/929/1875a3929dd14c8ea5ff4ccc3d0db9bd.gif)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/80776314-44e0-4791-9e4c-6dc070e31144)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/dc5eac88-ecb7-4421-8a1c-e796066fa449)

Сложность алгоритма посчитать также нетрудно. Так как один проход по массиву имеет сложность O(N), установить, что массив уже отсортирован, быстрее невозможно, поэтому в ЛУЧШЕМ случае сложность составляет именно O(N)

### Пузырьковая сортировка: инвариант
![image](https://github.com/mireashik/aood_3sem/assets/49165758/a35c39ab-345c-4479-a76e-c8ba627a3edd)

Самый тяжёлый из ещё не обработанных элементов, подобно пузырьку, «всплывает» на свою позицию

### Сортировка пузырьком: особенности
При пузырьковой сортировке сравниваются соседние элементы и меняются местами, если следующий элемент меньше предыдущего. Требуется несколько проходов по данным.

### 2.2.4 Сортировка вставками (Insertion sort)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/c74694cd-908d-48fb-b3fa-8a5250684f4d)

После i-го прохода по массиву в первых i позициях будут находиться отсортированные i элементов первоначального массива.

### Сортировка вставками: особенности
![image](https://github.com/mireashik/aood_3sem/assets/49165758/9d8b1734-f08c-49aa-a6f5-0d09b34b724c)

### 2.2.5 Сортировка Шелла
Но почему обязательно нужно обменивать местами только соседние элементы? Может быть, попробовать обменивать элементы с расстоянием $d > 1$?

![image](https://github.com/mireashik/aood_3sem/assets/49165758/5c0603f5-2aac-4a24-85f5-96740fe53f5d)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/947b978c-6468-4aba-9b8d-d34b9933dbc8)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/5fb80d23-d766-4cfb-8f0a-ffccdf11b364)

Сам Шелл предложил выбирать шаги сортировки в виде убывающей геометрической прогрессии с шагами $N/2 , N/4 , . . . , 1$

![image](https://github.com/mireashik/aood_3sem/assets/49165758/486fec3c-6552-4d4c-a1ad-9c306ad8ebbe)

В первых строках выбирается начальный шаг, который затем уменьшается по приведённому закону.

### Сортировка Шелла: особенности
![image](https://github.com/mireashik/aood_3sem/assets/49165758/169b4e62-2797-4abe-a50d-5eeae63a3127)

### 2.2.6 Сортировка выбором
А почему бы не уменьшить количество обменов элементов между собой?

![image](https://github.com/mireashik/aood_3sem/assets/49165758/60141c09-0a8a-492d-84d0-08cc41b140d3)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/f7e61d37-cb5b-438a-9ff5-ebd32f5d6acf)

### 2.2.7 Нахождение k-й порядковой статистики
k-й порядковой статистикой массива называется k-й по упорядочиванию величины элемент массива

Минимальный элемент массива ‒ 1-я
<br>
Максимальный элемент - порядковая статистика N

Пусть нужно найти $k = 6$ порядковую статистику в массиве:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/8410ad28-6786-4325-a99e-5c691740c224)

Пусть рулетка выпала на элемент со значением «элемент 8»

Разбиваем на 3 массива:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/874a1e3f-ccd3-4f33-b111-b44e95be4051)

Очевидно, что искомое находится в первом множестве; $k < |S_1|$ → первый случай.

Проделаем 2 итерацию:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/87ae0e93-6b34-458b-9f07-5dadbcb8ea42)

Пусть случайным образом выбран элемент 5:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/24fc480c-33c0-4063-a3b1-17719f904a21)

Выбран произвольный элемент 6:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/8c558d92-c795-4d78-a7cc-6fbe464ce1d9)

### Нахождение k-статистики. Сложность
Алгоритм относится к классу алгоритмов разделяй и властвуй

Таким образом, у нас появился алгоритм, который в среднем способен находить k-ю порядковую статистику за время $O(N)$, или, как говорят, за линейное время, но в маловероятных худших случаях его сложность может составлять $O(N^2)$

### 2.2.8 Быстрая сортировка
Почти повторяет алгоритм поиска k-й порядковой статистики.
<br>
 В его основе лежит -разбиение массива ведущим элементом на 2 подмассива ‒ и рекурсивная сортировка левой и правой частей. 

![image](https://github.com/mireashik/aood_3sem/assets/49165758/b9727b06-3794-4b39-8c03-86cbe1505cc1)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/55963edd-930e-465c-9df7-a602318bd2de)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/ebc7bdb2-e5b5-426d-b635-b3cfa40ac002)

И левая, и правая части нового массива, в конце концов, оказались достаточно малы для того, чтобы избежать рекурсии. Пусть в нашем примере такая граница проходит для массивов длиной 5 или меньших. На этом этапе в качестве «обычной» сортировки популярен алгоритм с**ортировки обменом**:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/9c173df7-2d61-4fd1-9280-9ef3e20f5339)

$S_{1r}$ после обычной сортировки станет равным $S_{1r}$ ={10, 13, 14, 18} Так как и левая, и правая части массива на каждом из этапов сортируются на месте (а ведущий элемент на месте уже находился), то массив оказывается отсортирован.

### Быстрая сортировка: сложность
На практике один из простых способов ‒ выбрать медианный элемент из трёх случайных элементов массива.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/5f257d56-1228-44a0-9c0a-b8efd40f185a)

### 2.2.9 Сортировка слиянием
Алгоритмы нахождения k-статистики и быстрой сортировки основаны на операции выборки ‒ нахождения k-го минимального элемента в массиве. 
<br>
Но можно объединять уже отсортированные массивы

![image](https://github.com/mireashik/aood_3sem/assets/49165758/0f09ca25-1428-4feb-a3c7-bf38f5245168)

Установив порог перехода на обычную сортировку в 3 элемента:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/84822d44-b8f8-483a-9682-3479ce781e90)

### Сортировка слиянием: сложность
В данном алгоритме мы наблюдаем классический пример работы принципа разделяй и властвуй ‒ обработка различных частей массива совершенно независима, следовательно, работает основная теорема о рекурсии

![image](https://github.com/mireashik/aood_3sem/assets/49165758/16b9a999-dc1d-4c28-bbe5-4117dd8b6ecc)

Интересный и полезный факт: **сложность не зависит от входных данных** и всегда равна O(N log N) 10 .

Прекрасно подходит для внешней сортировки, то есть сортировки файлов.

### 2.3. Нижняя оценка сложности алгоритмов
Обратили ли вы внимание на то, что самые быстрые алгоритмы, QuickSort и слиянием, имеют одинаковую сложность O(NlogN)? Возможно ли, не меняя условие  задачи, ‒ а оно заключается в том, что мы упорядочиваем два элемента на основе операции сравнения, ‒ придумать алгоритм сортировки с меньшей сложностью?

Оказывается, невозможно.

### 2.3.1. Деревья решений
![image](https://github.com/mireashik/aood_3sem/assets/49165758/221cfc84-1fbd-41e6-965d-75b39d76b808)
