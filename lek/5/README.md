## Бинарные деревья
### 1.1. Общие положения
Двоичные деревья - сочетают уникальности массив + связный список

Массив - медленное добавление / удаление, так как нужно переместить все элементы, что часто больше половины элементов
<br>
Связный список - медленный поиск, чтобы найти элемент нужно пройти по всем элементам

### Что же такое дерево?
Дерево - узлы и рёбры. (позже рассмотрим двоичное дерево)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/2dd161d2-ad13-425c-bdb2-fcd4eb35937e)

Двоичное дерево - каждый узел не более 2 потомков.

- Путь
- Корень
- Родитель
- Потомок
- Лист
- Поддерево
- Посещение
- Обход (все узлы)
- Уровни (поколения)
- Ключи (значения)

В двоичном дереве может быть не только 2 потомка, но только левый или правый. Или быть листом.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/962d3604-bd08-476a-b68d-7456bd49e652)

ключ левого потомка < родителя, правого >= родителю

### 1.2. Основные определения

Конечное корневое дерево T - связный ориентированный ациклический граф, с условиями:
- 1 вершина корень
- в каждую вершину 1 ребро
- из корня к любой вершине есть путь (единственный)

Лес - граф с несколькими деревьями
<br>
Степень вершины - число сыновей вершины (то есть у бинарного дерева степень не более 2!)
<br>
Высота - максимальный уровень листьев

Упорядоченные деревья будут отличаться если вершины переставить местами (ниже деревья не равны):

![image](https://github.com/mireashik/aood_3sem/assets/49165758/e3828363-8095-4e35-82ec-03e7d4305ee9)

В бинарном дереве важный сын левый или правый (ниже бинарные деревья не равны):

![image](https://github.com/mireashik/aood_3sem/assets/49165758/9c98cbeb-b45c-49d6-9d70-539e12eb8d8a)

- Терминальный узел (лист) – элемент дерева, который не имеет потомков.
- Внутренний узел – элемент дерева, который имеет потомков.

### 1.3 Представления деревьев
![image](https://github.com/mireashik/aood_3sem/assets/49165758/98fff7a8-195c-41a2-90dc-07db29ffbad1)

Можно представить как связный список (данные и указатели на левый и правый потомок):

![image](https://github.com/mireashik/aood_3sem/assets/49165758/217efcb1-a67a-403c-8a1f-ca0457a17bca)

Можно двигаться в дереве задом наперёд:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/0aea63bf-760d-4d61-b2c5-415592117d3b)

Проблемы будут если число сыновей у многих вершин слишком маленькое - сильно тратиться память, поэтому преобразуем лес в бинарное дерево

![image](https://github.com/mireashik/aood_3sem/assets/49165758/6cc1f308-7ccb-47b6-8fa8-47ac811ea1cc)

### 1.3.1 Представление дерева, через изученные структуры
Дерево через линейный массив, a[i] - указатель на родитель узла:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/a13885d6-0340-4984-82c5-0771d29b2153)

Дерево через связный список, список - потомки каждого узла:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/081fe2cf-73a9-45ba-8958-0bb1d73d1cc5)

Можно перейти от индекса массива к индексу ячейки массива:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/3969f545-5d77-46fd-90b0-00b46e5ef72c)

### 2. Прохождение деревьев
Прохождение - пошаговый перебор всех элементов дерева.

Всего 4 обхода:
- Прямой (предупорядоченный, в глубину) - обход сначала предок, потом потомок (сын)
- Обратный (поступорядоченный, снизу вверх) - сначала потомки, потом предки
- Симметричный (только для бинарных) - сначала обратный обход левое поддерево, затем корень, затем правое поддерево
- Горизонтальный (в ширину) - обход уровень за уровнем, слева направо

Обход в глубину:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/061883cd-6eca-4bab-a4b9-922554e34786)

Обход снизу вверх:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/0a806973-83ed-4058-937c-2efd409c601c)

Прямой и обратный порядок прохождения деревьев используется в компиляторах для преобразования арифметических и логических выражений в бесскобочную запись (прямая и обратная польская запись).

![image](https://github.com/mireashik/aood_3sem/assets/49165758/1aa3fdf2-c4ad-4e12-ba7f-a92a6c7f4abc)

Симметричный обход:

1. Пройти в симметричном порядке левое поддерево
2. Посетить корень
3. Пройти в симметричном порядке правое поддерево

![image](https://github.com/mireashik/aood_3sem/assets/49165758/7290f335-32ea-4aec-84ae-b11967593e9d)

Обход в ширину:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/ef02affa-8087-4143-9595-9d248c7728f2)

При нумерации в прямом порядке все вершины поддерева с корнем r имеют номера, не меньшие r. Можно будет понять вершина w потомок для v или нет.

### 3. Реализация бинарного дерева на С++
![image](https://github.com/mireashik/aood_3sem/assets/49165758/36ef9fde-7740-4222-af5b-44dc2844c09b)

Строго бинарное - если нет пустых узлов (листов)
<br>
Идеально сбалонсированное - если число левых и правых деревьев меньше чем на 1
<br>
Дерево поиска - если любая вершина v содержит в левом поддереве вершины - меньше v, правое поддерево - больше v

```c++
struct Node { // Звено дерева
  int x; // число записанное в дерево
  Node *l,*r; // адрес левой / правой части
};

// Функция для обхода и отображения дерева
void show(Node *&Tree) {
    if (Tree != NULL) { // Пока не встретится пустое звено
        show(Tree -> l);  // Рекурсивная функция для вывода левого поддерева
        cout << Tree -> x; // Отображаем корень дерева
        show(Tree -> r);  // Рекурсивная функция для вывода правого поддерева
    }
}

// Функция для добавления звена в дерево
void add_node(int x, Node *&MyTree) {
    if (NULL == MyTree) { // Если дерева нет, то сеем семечко
        MyTree = new Node; // Выделяем память под звено дерева
        MyTree -> x = x;     // Записываем данные в звено
        MyTree -> l = MyTree -> r = NULL; // Подзвенья инициализируем пустотой, во избежание ошибок
    }

    // записи для левого дерева
    if (x < MyTree -> x) {
        // Если у корневого звена уже есть левое подзвено, вызываем рекурсивно add_node для него
        if (MyTree -> l != NULL) {
            add_node(x, MyTree->l);
        }
        else {
            // Если левого подзвена нет, создаем его и инициализируем пустыми подзвеньями
            MyTree -> l = new Node;
            MyTree -> l -> l = MyTree -> l -> r = NULL;
            MyTree -> l -> x = x; // Записываем в левое подзвено записываемый элемент
        }
    }

    // записи для правого дерева
    if (x > MyTree -> x) {
        // Если у корневого звена уже есть правое подзвено, вызываем рекурсивно add_node для него
        if (MyTree -> r != NULL) {
            add_node(x, MyTree->r);
        }
        else {
            // Если правого подзвена нет, создаем его и инициализируем пустыми подзвеньями
            MyTree -> r = new Node;
            MyTree -> r -> l = MyTree -> r -> r = NULL;
            MyTree -> r -> x = x; // Записываем в правое подзвено записываемый элемент
        }
    }
}

/* Добавили очистку памяти */
void del(Node *&Tree) {
    if (Tree != NULL) { // Пока не встретится пустое звено
        del(Tree -> l); // Рекурсивная функция прохода по левому поддереву
        del(Tree -> r); // Рекурсивная функция для прохода по правому поддереву

        delete Tree; // Убиваем конечный элемент дерева
        Tree = NULL; // Может и не обязательно, но плохого не будет
    }
}

int main() {
    Node *Tree = NULL; // Создание указателя, тип которого - звено дерева, и
                       // инициализация его значением NULL (пустое дерево)
    for (int i=5; i>0; i--)
      add_node(i,Tree); // вводим 5-4-3-2-1для последующего вывода на экран
    show(Tree); //Вывод на экран дерева или просто обход дерева
    cin.get();
    return 0;
}
```

Другие примеры доступны в PDF файле!
