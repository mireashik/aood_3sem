## Стеки
### 1. Алгоритмы и абстрактный тип данных
Одним из старейших численных алгоритмов - алгоритм Евклида

«Алгоритм – конечный набор правил, который определяет последовательность операций для решения множества задач и обаладет 5 чертами: конечность, определённость, ввод, вывод, эффективность»

«Алгоритм - система вычислений, выполняемых по строго определённым правилам, которая после какого-либо числа шагов заведомо приводит к решению поставленной задачи»

#### Практическая применимость теории алгоритмов
1. Является задача в принципе алгоритмически разрешимой? В случае «ДА» возникает следующий вопрос: Принадлежит ли эта задача к классу NP–полных задач? При утвердительном ответе, анализируют временные затраты на получения точного решения для больших размерностей исходных данных.
2. Для алгоритмически неразрешимых задач возможно ли их сведение к задаче останова машины Тьюринга?

- рациональный выбор из известного множества алгоритмов
- получение временных оценок решения сложных задач
- получение достоверных оценок невозможности решения
- разработку и совершенствование эффективных алгоритмов

**Алгоритм** – заданное на языке конечное предписание, конечная последовательность выполнимых элементарных операций для решения задачи, общее для класса возможных исходных данных.

D – область (множество) исходных данных задачи, а R – множество возможных результатов, тогда алгоритм осуществляет отображение D → R.

Частичный алгоритм - для некоторых d ∈ D, полный алгоритм - для всех d ∈ D

Алгоритм – точный набор инструкций, описывающих порядок действий исполнителя для достижения результата решения задачи за конечное время.

- конечное количество предписаний
- конечное количество шагов
- единым для всех исходных данных
- приводить к правильному решению

#### Формальные свойства алгоритмов
- полезность (умение решать)
- дискретность (последовательность решения)
- детерменированность (однозначное решение)
- понятность (все команды доступны)
- завершаемость (конечность)
- массовость (для разных задач)
- корректность (верно для всех задач)
- эффективность (быстро по времени)

Каждая структура данных реализует набор функций интерфейса (для операций над структурой). Для точного описания - формальные обозначения. 

### Абстрактный тип данных (АТД)
Математическую модель данных и операции, определенных для этих данных. АТД выбирате заданную структуру данных и операции над ней. АТД - класс в ООП. 

Абстрактный тип данных:
- операции над элементами этого типа
- данные относительно которых выполняются операции (значения)

Абстракция сводит всё к нужным деталям, ненужные выкидываются.

Абстрактный тип данных – тип данных, скрывает свою внутреннюю реализацию от клиентов или исполнителей. Определяем интерфейс - операции над данными и в итоге получаем структуру данных. 

Абстрактный тип данных инкапсулирует эти данные, что позволяет менять работу объектов этого типа, а не всей программы. 

Преимущества АТД
- инкапсуляция деталей реализации (интерфейс можно оставить одинаковый, но внутри менять и улучшать его)
- снижение сложности (что может делать, а не как делать)
- ограничение области использования данных (данные не зависимы)
- высокая информативность интерфейса 

Класс = АТД + Наследование + Полиморфизм

Инкапсуляция - сокрытие поведения объекта внутри него (интерфейс)
<br>
Наследование - один объект приобретает свойства другого
<br>
Полиморфизм - различная реализация

### 2. Операции над стеком
Стек - доступен только последний элемент.

Использование:
- перебор узлов дерева
- поиск вершин графа
- микропроцессоры
- старые калькуляторы
- веб браузер
- текстовые/графические редакторы

![image](https://github.com/mireashik/aood_3sem/assets/49165758/6a9bb5e0-b95e-4339-8b5c-c2d6d670483a)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/45e30878-5e90-43b5-8309-039f0433aa44)

Новый элемент добавляется в вершину стека, сдвигая остальные элементы последовательности, «последним пришел – первым ушел» и часто называется структурой **LIFO** (Last In – First Out).

![image](https://github.com/mireashik/aood_3sem/assets/49165758/55f43891-62dd-4fee-853d-b5e4ca1af218)

Стек S является абстрактным типом данных, который поддерживает следующие основные методы:
1. push(S,x) - объект x в вершину стека
2. pop(S) - удаляет объект из стека
3. size(S) - число объектов
4. isEmpty(S) - проверяет что стек пуст
5. topValue(S) - возвращение верхнего объекта, не удаляя его
6. 
### 3. Реализация стека и основных операций над стеком
#### Стек - массив
Эффективная реализация - массив, для хранения элементов стека. Вершина стека (последний элемент) - переменная t

![image](https://github.com/mireashik/aood_3sem/assets/49165758/2cc3b8ab-6470-4bc5-9fb1-da58d4fc179d)

Операция исключения из вершины стека **НЕ УДАЛЯЕТ ЭЛЕМЕНТ**:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/1b19759d-187d-4c8d-b052-6cf05cacbb84)

Размер стека обычно известен заранее (t также может использоваться для размера)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/5af0086e-b653-4267-8bf5-99bff9c5beb4)

```python
Algorithm size():
  // возвращение числа элементов стека (определение размера стека)
  1 return t + 1

Algorithm isEmpty():
  // возвращает логическое значение, подтверждающее, что стек S пуст.
  1 return (t < 0)

Algorithm topValue(s):
  // возвращает верхний объект в стеке, не удаляя его
  1 if isEmpty() then
  2   вызов StackEmptyExceptior
  3 return S[t]

Algorithm push(x):
  // помещает объект x в вершину стека S
  1 if size() = N then
  2   вызов StackFullExceptior
  3 t ← t + 1
  4 S[t] ← x

Algorithm pop():
  // удаляет объект из стека S и возвращает новый верхний объект стека S
  1 if isEmpty() then
  2   вызов StackEmptyExceptior
  3 e ← S[t]
  4 S[t] ← null
  5 t ← t – 1
  6 return e

```

Недостаток последовательной реализации СТЕКА - фиксированный размер.  Потому что массив - статическая структура, а стек - динамическая структура.
<br>
От указанного недостатка свободна реализация СТЕКА с использованием связного распределения (динамических списковых структур).

#### Стек - односвязный список
![image](https://github.com/mireashik/aood_3sem/assets/49165758/db801bb7-217e-48f6-be0c-bef0d3f91585)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/b77c8925-07ca-4c77-9251-d6486314beeb)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/13575449-22d3-4603-9733-ee275f2382d0)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/de736859-dd14-4fa2-87a0-b06de2f842e7)

Имеет преимущество по сравнению с реализацией на основе массива – нужно указывать максимальный размер стека.

Используем переменную ссылочного типа top для обращения к началу списка (имеет 0 значение при пустом списке).
<br>
При добавлении в стек нового элемента е создается новый узел v, из v устанавливается ссылка на е, и v добавляется в начало списка.
<br>
При извлечении элемента из стека узел удаляется из начала списка и возвращается его элемент.

### 4. Реализация стека на С++
Стек – частный случай линейного списка.

```c++
struct Single_List {
    // Структура для односвязного списка, предположим, у вас есть такая структура
    // Это может включать поля для данных и указатель на следующий элемент списка.
    // Например:
    int data;
    Single_List* next;
};

struct Stack {
    Single_List* Top; // Вершина стека - указатель на верхний элемент
};

// Где-то в вашем коде вы создаете указатель на стек:
Stack* Top_Stack;
```

```c++
// Создание нового стека
Stack* myStack = new Stack;

// Добавление элемента в стек
Single_List* newElement = new Single_List;
newElement->data = 42;
newElement->next = myStack->Top; // Присваиваем указателю next значение текущей вершины
myStack->Top = newElement; // Обновляем вершину стека

// После этого вершина стека будет указывать на новый элемент с данными 42.
```
