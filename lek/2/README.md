## Стеки
### 1. Алгоритмы и абстрактный тип данных
Одним из старейших численных алгоритмов - алгоритм Евклида

«Алгоритм – конечный набор правил, который определяет последовательность операций для решения множества задач и обаладет 5 чертами: конечность, определённость, ввод, вывод, эффективность»

«Алгоритм - система вычислений, выполняемых по строго определённым правилам, которая после какого-либо числа шагов заведомо приводит к решению поставленной задачи»

#### Практическая применимость теории алгоритмов
1. Является задача в принципе алгоритмически разрешимой? В случае «ДА» возникает следующий вопрос: Принадлежит ли эта задача к классу NP–полных задач? При утвердительном ответе, анализируют временные затраты на получения точного решения для больших размерностей исходных данных.
2. Для алгоритмически неразрешимых задач возможно ли их сведение к задаче останова машины Тьюринга?

- рациональный выбор из известного множества алгоритмов
- получение временных оценок решения сложных задач
- получение достоверных оценок невозможности решения
- разработку и совершенствование эффективных алгоритмов

**Алгоритм** – заданное на языке конечное предписание, конечная последовательность выполнимых элементарных операций для решения задачи, общее для класса возможных исходных данных.

D – область (множество) исходных данных задачи, а R – множество возможных результатов, тогда алгоритм осуществляет отображение D → R.

Частичный алгоритм - для некоторых d ∈ D, полный алгоритм - для всех d ∈ D

Алгоритм – точный набор инструкций, описывающих порядок действий исполнителя для достижения результата решения задачи за конечное время.

- конечное количество предписаний
- конечное количество шагов
- единым для всех исходных данных
- приводить к правильному решению

#### Формальные свойства алгоритмов
- полезность (умение решать)
- дискретность (последовательность решения)
- детерменированность (однозначное решение)
- понятность (все команды доступны)
- завершаемость (конечность)
- массовость (для разных задач)
- корректность (верно для всех задач)
- эффективность (быстро по времени)

Каждая структура данных реализует набор функций интерфейса (для операций над структурой). Для точного описания - формальные обозначения. 

### Абстрактный тип данных (АТД)
Математическую модель данных и операции, определенных для этих данных. АТД выбирате заданную структуру данных и операции над ней. АТД - класс в ООП. 

Абстрактный тип данных:
- операции над элементами этого типа
- данные относительно которых выполняются операции (значения)

Абстракция сводит всё к нужным деталям, ненужные выкидываются.

Абстрактный тип данных – тип данных, скрывает свою внутреннюю реализацию от клиентов или исполнителей. Определяем интерфейс - операции над данными и в итоге получаем структуру данных. 

Абстрактный тип данных инкапсулирует эти данные, что позволяет менять работу объектов этого типа, а не всей программы. 

Преимущества АТД
- инкапсуляция деталей реализации (интерфейс можно оставить одинаковый, но внутри менять и улучшать его)
- снижение сложности (что может делать, а не как делать)
- ограничение области использования данных (данные не зависимы)
- высокая информативность интерфейса 

Класс = АТД + Наследование + Полиморфизм

Инкапсуляция - сокрытие поведения объекта внутри него (интерфейс)
<br>
Наследование - один объект приобретает свойства другого
<br>
Полиморфизм - различная реализация

### 2. Операции над стеком
Стек - доступен только последний элемент.

Использование:
- перебор узлов дерева
- поиск вершин графа
- микропроцессоры
- старые калькуляторы
- веб браузер
- текстовые/графические редакторы

![image](https://github.com/mireashik/aood_3sem/assets/49165758/6a9bb5e0-b95e-4339-8b5c-c2d6d670483a)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/45e30878-5e90-43b5-8309-039f0433aa44)

Новый элемент добавляется в вершину стека, сдвигая остальные элементы последовательности, «последним пришел – первым ушел» и часто называется структурой **LIFO** (Last In – First Out).

![image](https://github.com/mireashik/aood_3sem/assets/49165758/55f43891-62dd-4fee-853d-b5e4ca1af218)

Стек S является абстрактным типом данных, который поддерживает следующие основные методы:
1. push(S,x) - объект x в вершину стека
2. pop(S) - удаляет объект из стека
3. size(S) - число объектов
4. isEmpty(S) - проверяет что стек пуст
5. topValue(S) - возвращение верхнего объекта, не удаляя его

### 3. Реализация стека и основных операций над стеком
#### Стек - массив
Эффективная реализация - массив, для хранения элементов стека. Вершина стека (последний элемент) - переменная t

![image](https://github.com/mireashik/aood_3sem/assets/49165758/2cc3b8ab-6470-4bc5-9fb1-da58d4fc179d)

Операция исключения из вершины стека **НЕ УДАЛЯЕТ ЭЛЕМЕНТ**:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/1b19759d-187d-4c8d-b052-6cf05cacbb84)

Размер стека обычно известен заранее (t также может использоваться для размера)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/5af0086e-b653-4267-8bf5-99bff9c5beb4)

```python
Algorithm size():
  // возвращение числа элементов стека (определение размера стека)
  1 return t + 1

Algorithm isEmpty():
  // возвращает логическое значение, подтверждающее, что стек S пуст.
  1 return (t < 0)

Algorithm topValue(s):
  // возвращает верхний объект в стеке, не удаляя его
  1 if isEmpty() then
  2   вызов StackEmptyExceptior
  3 return S[t]

Algorithm push(x):
  // помещает объект x в вершину стека S
  1 if size() = N then
  2   вызов StackFullExceptior
  3 t ← t + 1
  4 S[t] ← x

Algorithm pop():
  // удаляет объект из стека S и возвращает новый верхний объект стека S
  1 if isEmpty() then
  2   вызов StackEmptyExceptior
  3 e ← S[t]
  4 S[t] ← null
  5 t ← t – 1
  6 return e

```

Недостаток последовательной реализации СТЕКА - фиксированный размер.  Потому что массив - статическая структура, а стек - динамическая структура.
<br>
От указанного недостатка свободна реализация СТЕКА с использованием связного распределения (динамических списковых структур).

#### Стек - односвязный список
![image](https://github.com/mireashik/aood_3sem/assets/49165758/db801bb7-217e-48f6-be0c-bef0d3f91585)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/b77c8925-07ca-4c77-9251-d6486314beeb)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/13575449-22d3-4603-9733-ee275f2382d0)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/de736859-dd14-4fa2-87a0-b06de2f842e7)

Имеет преимущество по сравнению с реализацией на основе массива – нужно указывать максимальный размер стека.

Используем переменную ссылочного типа top для обращения к началу списка (имеет 0 значение при пустом списке).
<br>
При добавлении в стек нового элемента е создается новый узел v, из v устанавливается ссылка на е, и v добавляется в начало списка.
<br>
При извлечении элемента из стека узел удаляется из начала списка и возвращается его элемент.

### 4. Реализация стека на С++
Стек – частный случай линейного списка.

```c++
struct Single_List {
    int data; // поля для данных
    Single_List* next; // указатель на следующий элемент списка
};

struct Stack {
    Single_List* Top; // Вершина стека - указатель на верхний элемент
};

// Где-то в вашем коде вы создаете указатель на стек:
Stack* Top_Stack;
```

```c++
// Создание нового стека
Stack* myStack = new Stack;

// Добавление элемента в стек
Single_List* newElement = new Single_List;
newElement -> data = 42;
newElement -> next = myStack -> Top; // Присваиваем указателю next значение текущей вершины
myStack -> Top = newElement; // Обновляем вершину стека

// После этого вершина стека будет указывать на новый элемент с данными 42.
```

Реализовать структуру данных СТЕК можно на основе массива или линейного списка. Рассмотрим пример реализации основных операций со стеком на основе связного списка.

```c++
#include <stddef.h>
#include <stdio.h>
#include <iostream>

// Определение структуры zveno
struct zveno {
    int info = 0; // элемент структуры
    zveno* next; // ссылки на адрес последующего элемента
}; // последовательность элементов,

// Функция для вывода содержимого стека
int Print(zveno* &s) {
    zveno *v = s;
    if (v == NULL) { // переданный параметр v пустой
        printf("стек пуст\n");
    }

    while (v != NULL) { // ПОКА v не пустое
        printf("%d ", v->info);
        v = v->next; // переход к следующему элементу в структуре
    }

    cout << "\n";
    return 1;
}

// Функция для добавления элемента в стек
zveno* Push(zveno* &s, int a) {
    zveno *v;
    v = new zveno;
    v->info = a;
    v->next = s;
    s = v;
    return s;
}

// Функция для удаления элемента из стека
zveno* Pop(zveno* &s) {
    zveno *v = s;
    s = s->next;
    delete v;
    return s;
}

// Функция для проверки, пуст ли стек
int Empty(zveno* &s) {
    if (s == NULL) {
        return 1;
    } else {
        return 0;
    }
}

// Главная функция программы
int main() {
    zveno *theStack;
    theStack = new zveno;

    Print(theStack);
    Push(theStack, 20);
    Push(theStack, 40);
    Push(theStack, 60);
    Push(theStack, 80);

    Print(theStack);

    Pop(theStack);
    Pop(theStack);

    Print(theStack);

    Push(theStack, 100);
    Print(theStack);

    return 1;
}
```

Представленная ниже программа заполняет (PUSH) стек целочисленными данными с помощью функции create, а затем содержимое стека печатается (POP) в обратном порядке функцией list. Это основная особенность стека – чем позже элемент занесен в стек, тем раньше он будет извлечен из стека. Реализация стека выполнена в связанном хранении при помощи указателя next на тип, именованный именем stack.

```c++
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>

// Определение структуры stack
struct stack {
    int data;
    struct stack *next;
};

struct stack *create(struct stack *, int x); // Объявляем функцию присоединения элемента к вершине
void list(struct stack *); //Описание функции просмотра стека с параметром

int main(int argc, char* argv[]) {
    int i, n;
    struct stack *head; // head - начало стека

    head = NULL;

    printf(" *** ДЕМОНСТРАЦИЯ СТЕКА ***\n");
    printf("\nВВЕДИТЕ ЧИСЛО БОЛЬШЕ 5: ");
    scanf("%d", &n);

    printf("\nЗАПОЛНЕНИЕ СТЕКА: ");

    // Заполнение стека значениями с шагом 5
    for (i = 0; i <= n; i += 5) {
        head = create(head, i); // текущий элемент стека
        printf("%d <- ", head->data); // вывод на экран значений стека
    }

    printf("\n");

    // Вывод содержимого стека
    list(head);

    // Освобождение памяти, выделенной для стека
    free(head);

    // Ожидание ввода символа для завершения программы
    getch();

    return 0;
}

// Функция создания нового элемента стека
struct stack *create(struct stack *head, int x) {
    struct stack *element;
    element = (struct stack *)malloc(sizeof(struct stack)); // выделяем память для новой структуры размером необходимым для структуры stack
    element -> next = head; // элемент структуры добавляется в конец списка, последующим после него идет старый элемент
    element -> data = x; // добавление значения для нового элемента списка
    return element; // новый элемент стека с указанием на последующие элементы
}

// Функция для вывода содержимого стека
void list(struct stack *p) {
    printf("\n ВЫВОД СТЕКА: ");

    // Просмотр стека
    while (p != NULL) { // пока стек не пуст
        printf("%d -> ", p->data);
        p = p->next; // продвижение по списку переход по элементам стека
    }
}
```
