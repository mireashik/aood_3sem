## Графы. Часть 1.
### 1. Основные понятия и определения.
Граф ‒ множества вершин и множества соединяющих их рёбер. Граф G состоит из множества V. 
<br>
Вершины v и w лежат на ребре e, ребро e инцидентно вершинам v и w.

Смежность вершин - 2 вершины называются смежными, если они инцидентны 1 ребру
<br>
Мультиграф - граф с кратными рёбрами
<br>
Псевдомультиграф - граф с петлями и кратными рёбрами
<br>
Изолированная вершина - вершина с 0 степенью
<br>
Висячая вершина - вершина с 1 степенью
<br>
Полный граф - каждые 2 вершины соединены одним ребром: `N * (N - 1) / 2`
<br>
Регулярный граф - степени одинаковые для всех вершин.
<br>
Двудольный граф - вершины графа можно разделить на 2 множества
<br>
Связный граф - пара его вершин соединена маршрутом

![image](https://github.com/mireashik/aood_3sem/assets/49165758/66801ae1-98a7-4176-a6bb-efa7b46762fc)

### 1.1.2. Неориентированные графы
Маршрут/цепь - последовательность различающихся вершин, каждая из которых является смежной по отношению к другой
<br>
Цикло - цепь более 3 вершин, начало = конец

![image](https://github.com/mireashik/aood_3sem/assets/49165758/01c74183-dd6e-470c-bd9e-af31789c6412)

### 1.1.3. Ориентированные графы
Сильносвязный граф - от любой вершины к любой другой вершине имеется направленный маршрут
<br>
Слабосвязный граф - при удалении ребер неориентированный граф получился связным

![image](https://github.com/mireashik/aood_3sem/assets/49165758/2f3d6d21-b0e6-4bdb-91c4-1fd992e02331)

### 1.1.4. Остовное дерево
Остовное дерево графа (или стягивающее, покрывающее дерево, каркас графа, скелет) - дерево со всеми вершинами исходного графа, без циклов и контуров

На связном графе можно построить более чем 1 остовное дерево
<br>
Для взвешенного графа существует по крайней мере 1 минимальное остовное дерево.

Минимальное остовное дерево (или минимальное покрывающее дерево) в (неориентированном) связном взвешенном графе ‒ остовное дерево с минимальным весом
<br>
вес дерева - сумма всех весов рёбер

**Алгоритм Борувки-Соллина** - последовательное добавление рёбер к остовному лесу графа, пока лес не превратится в дерево (1 компонента связности), общее время работы алгоритмы составляет O(ElogV)
<br>
Для планарных графов время может быть уменьшено до O(E)

**Алгоритм Ярника-Прима** - рандомизированный алгоритм МОД, работающий в среднем за линейное время.

- матрица смежности ‒ О(|V|)
- двоичная куча и список смежности ‒О(|Е|log|V|)
- куча Фибоначчи и список смежности ‒ О(|Е|+|V|log|V|)

**Алгоритма Краскала** - для начала необходимо отсортировать рёбра по весу. Текущее множество рёбер - пустое. Затем добавляются рёбра, которые не вызовут цикла, выбирается минимальный вес (жадный алгоритм), и добавляется к текущему множеству
<br>
Остовные деревья нужны в компьютерных сетях. По протоколу STP (Spanning TreeProtocol – протокол остовного дерева) производится управление коммутаторами в локальных сетях Ethernet.

### 2.1. Компьютерное представление
#### Представление в виде множества
Графы - множество вершин, множество пар, множество вершин. 
<br>
Граф G состоит из множества V, называемого вершинами графа G, вершины - подмножество Av множества V
<br>
Для ориентированного графа пара (w,v) не равна паре (v,w)

#### 2.1.2. Реализация множеств
Есть 2 общих способа реализации множества вершин.
<br>
1 способ - представлении множества как списка его элементов
<br>
2 способ - битовая строка, хранит булево значение (т.е. один бит) для каждого члена множества, имеется ли он в множестве или нет.

```c++
type
  vertex = 1..maxvertex; // идентифицируем вершины их индексами
  counter = 0..maxvertex; // счетчик вершин
  adjacencyset = set of vertex;
  graph = record
  size: counter; // число вершин в графе
  A: array[vertex] of adjacencyset
end;
```

A[v] - множество всех вершин, смежных с вершиной v

#### 2.1.3. Таблицы смежности
```c++
type
  vertex = 1..maxvertex; // идентифицируем вершины их индексами
  counter = 0..maxvertex; // счетчик вершин
  adjacencytable = array [vertex, vertex] of Boolean;
  graph = record
  size: counter; // число вершин в графе
  A: adjacencytable
end;
```

Таблица смежности A имеет естественную интерпретацию: элемент A[v, w] истинен, если и только если вершина v смежна с вершиной w.
<br>
Если граф ориентирован, A[v, w] - индикатор наличия ребра от v -> w
<br>
Если граф не ориентирован, таблица смежности симметрична A[v, w] = A[w, v]

![image](https://github.com/mireashik/aood_3sem/assets/49165758/953b2b84-d5a1-4fac-b561-8e03f3199daa)

#### 2.1.4. Списки смежности
Список смежности, каждой вершине графа соответствует список, состоящий из «соседей» этой вершины.

Для представления графа мы должны иметь 2 списка:
- список вершин;
- для каждой вершины, список смежных вершин.

С использованием как непрерывных списков, так и простых связных списков (в виде двоичных или многовариантных деревьев или в виде пирамид)
<br>

#### 2.1.5. Связная реализация
При использовании связных списков и для вершин, и для списков смежности, достигается максимальная гибкость.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/535c0cd4-2975-4228-8321-c133d9043c18)

```c++
type
pointvertex = vertex;
pointedge = edge;
vertex = record
firstedge: pointedge; //начало списка связности
nextvertex: pointvertex //следующая вершина в связном списке
end;
edge = record
endpoint: pointvertex; //вершина, на которую указывает ребро
nextedge: pointedge; //следующее ребро в списке связности
end;
graph = pointvertex; //заголовок списка вершин
```

#### Непрерывная реализация

#### Смешанная реализация

#### Информационные поля

### 2.2. Просмотр графа

#### Метод просмотра графа в глубину

#### Метод просмотра графа в ширину

#### Алгоритм просмотра графа в глубину

#### Алгоритм просмотра графа в ширину

### 3. Топологическая сортировка

### 3.2. Алгоритм упорядочения в глубину

### 3.3. Алгоритм упорядочения в ширину

### 3.4. Алгоритм экономного продвижения: кратчайшие маршруты

### Выводы
