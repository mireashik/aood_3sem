## Поиск и расстановка: основные понятия и определения
конечное множество $T$ из $n$ элементов, которое будем называть **ТАБЛИЦЕЙ**
<br>
Элементы таблицы связаны с **ключом.**

Поиск представляет собой запрос, возвращает указатель на имя из таблицы, совпадающее с z (успешный поиск).
<br>
В противном случае - пустое значение указателя, безуспешный поиск
<br>
любые 2 элемента на множестве $S$ сравнивы $x, y ∈ S$

![image](https://github.com/mireashik/aood_3sem/assets/49165758/de5116e8-ce65-40ca-a204-98c21afeda56)

Табличный порядок - определенный на таблице $T$
<br>
Статистические таблицы - не изменяются
<br>
Динамические таблицы - меняются (операции добавление / исключение, сортировка, объединение)

- Поиск z
- Включение z (включить)
- Исключение z (удаление)
- Распечатка (вывод всех имён)

Если табличный порядок не соответствует **ЕСТЕСТВЕННОМУ**, предполагается предварительная СОРТИРОВКА

**Сформулируем задачу поиска**

${k_1, k_2, k_3, … , k_n}$

- Сбор информации
- Организация информации
- Извлечение информации

![image](https://github.com/mireashik/aood_3sem/assets/49165758/141fddc2-f85c-4004-b65b-69f4eddc3746)

- ВНЕШНИМ поиск
- ВНУТРЕННИМ поиск

## ПОСЛЕДОВАТЕЛЬНЫЙ ПОИСК. МЕТОДЫ ОПТИМИЗАЦИИ ПОИСКА
Простейший вид поиска заданного элемента на некотором множестве, последовательное сравнение

![image](https://github.com/mireashik/aood_3sem/assets/49165758/9f1130b4-9c0a-4a40-979f-a9377bb86517)

```c++
int dummysearch(int a[], int N, int key) { 
  for (int i = 0; i < N; i++) {
    if (a[i] == key) { 
      return i; 
    } 
  } 
  return N; 
}
```

![image](https://github.com/mireashik/aood_3sem/assets/49165758/c0c28e94-aa28-4ffc-9b36-f4b9dd38bd9b)

В порядке невозрастания частот обращения

ШАГ 1. [Начальная установка]. Установить i:=1.
<br>
ШАГ 2. [Сравнение]. Если k=ki, алгоритм завершён, удача нам благоволит.
<br>
ШАГ 3. [Продвижение]. Увеличить i на 1.
<br>
ШАГ 4. [Конец файла?]. Если $i < N$, то вернуться к ШАГУ 2. В ином случае, что-то пошло не так и алгоритм завершается неудачей.

```c++
#include <iostream>
using namespace std;
void main() {
  setlocale(LC_ALL,"Rus");
  int i, n, key, nom;
  bool el=false;
  cout<<"Размер массива> "; cin>>n;
  int *mas= new int[n]; //динамический массив
  cout<<"Искомый массив> ";
  10
  cin>>key; //ввод искомого числа
  for (i=0; i<n; i++){
    mas[i]=rand()%100; //заполнение массива случайными числами
    cout<<mas[i]<<" "; //вывод массива
  }
  for (i=0; i<n; i++) { //если данный элемент равен искомому
    if (mas[i]==key) { //то el присваиваем true
    el=true; nom=i; break;
    } //и выходим из цикла
  }
  if (el==true)
  cout<<"\nЭлемент найден! его номер "<<nom+1<<endl;
  else
  cout<<"\ nЭлемент не найден "<<endl;
  delete []mas;
  system("pause");
}
```

O(n)

время вставки или удаления не зависит от количества элементов

### 2.2. Методы оптимизации поиска
Вся таблица поиска может быть представлена как система с дискретными состояниями, а вероятность поиска $i-го$ элемента ‒ это вероятность $p(i)$

![image](https://github.com/mireashik/aood_3sem/assets/49165758/9271018e-0404-4ffa-9046-849c7b11b024)

Так как последовательный поиск начинается с первого элемента, то на это место надо поставить элемент, к которому чаще всего обращаются

- переупорядочивание таблицы поиска путем перестановки найденного элемента в начало списка
- метод транспозиции

### 2.2.1 Переупорядочивание таблицы поиска путем перестановки найденного элемента в начало списка
остальные элементы сдвигаются

![image](https://github.com/mireashik/aood_3sem/assets/49165758/3a164596-3db3-4b0a-b5d9-d1a21bdb01fe)

- р ‒ рабочий указатель;
- q ‒ вспомогательный указатель, отстает на один шаг от р

Этот алгоритм применим как для списков, так и для массивов (но для массива не рекомендуется - на перестановку **элементов** массива затрачивается гораздо **больше** времени, чем на перестановку **указателей**)

```c++
q= nil
p = table
while (p <> nil) do
  if key = k(p) then
  search = p
  if q = nil
    then 'перестановка не нужна'
      return
  endif
nxt(q) = nxt(p)
  nxt(p) = table
  table = p
  return
endif
q = p
p = nxt(p)
endwhile
search = 0
return
```

### 2.2.2 Метод транспозиции
![image](https://github.com/mireashik/aood_3sem/assets/49165758/da2faa9f-9f28-4456-8a88-db100c78a65a)

- р ‒ рабочий указатель;
- q ‒ вспомогательный указатель, отстает на один шаг от р
- s ‒ вспомогательный указатель, отстает на два шага от р

Этот метод удобен при поиске не только в списках, но и в массивах

Завершая разговор о линейном поиске, необходимо отметить, что существует так называемый **индексно-последовательный** поиск, при таком поиске организуется 2 таблицы

1. Таблица данных со своими ключами
2. Таблица индексов, которая тоже состоит из ключей данных (но там есть интервал)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/3efa2a3b-1a8a-453b-ac85-1182c0febda3)

Для индексно-последовательного поиска в дополнение к **отсортированной** таблице заводится вспомогательная таблица, называемая **индексной** (рисунок 4.1)

сокращается время поиска, второй последовательный поиск выполняется по небольшой части записей основной таблицы

![image](https://github.com/mireashik/aood_3sem/assets/49165758/44dd1789-748c-4bc1-96a7-76c244e30574)

### Эффективность последовательно-индексного поиска
- n ‒ размер основной таблицы;
- m ‒ размер индексной таблицы;
- p ‒ размер шага;
- m = n/p

![image](https://github.com/mireashik/aood_3sem/assets/49165758/0b5ad35f-54ea-411a-aa3d-5618acd9acb6)

## 3.1. Логарифмический поиск в статических таблицах
### 3.1.1. Бинарный поиск

Бинарный (двоичный) поиск предъявляет ряд требований: 
- имена в таблице должны храниться в их естественном (отсортированном) порядке
- прямой доступ к именам таблицы

Бинарный поиск требует отсортированной таблицы, организованной в виде массива:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/b7fdbe23-8ecf-4773-894b-1a984b23a47c)

Первое сравнение − это корень дерева

![image](https://github.com/mireashik/aood_3sem/assets/49165758/485ed2af-5642-40f5-bdbb-0476edf13028)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/f1c049ed-512b-495e-9518-13b7d743423d)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/09a6474d-8d15-4625-8fb0-bc80dafdddae)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/9bcfa083-53ee-4b57-acbd-bff4100fa9e4)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/d22526f3-fd05-4081-9174-7aeb1608b98d)

### Встроенные функции
binary_search,  lower_bound возвращает итератор первого элемента, upper_bound, которая возвращает итератор на элемент, который строго больше искомого в заданном диапазоне упорядоченных элементов.

### Однородный бинарный поиск
Однородный (равномерный) бинарный поиск является модификацией обычного бинарного поиска

Вместо 3 указателей – l (нижняя граница интервала), h (верхняя граница интервала) и m (середина интервала) – используется только 2:
- текущая позиция m;
- величина его изменения δ.

в виде расширенного бинарного дерева, константа разности между вершинами

### 3.1.2. Поиск Фибоначчи
Последовательность фибоначчи: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89

Расширенное бинарное дерево (дерево Фибоначчи), соответствующее поиску Фибоначчи, показано на рисунке 6. Это дерево Фибоначчи порядка 6, то есть, корню дерева сопоставлено имя i=F6

![image](https://github.com/mireashik/aood_3sem/assets/49165758/cb97ee23-8b08-4780-b45f-a3314c49daa8)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/f610d7c0-74dd-4e2a-8e01-f20d6bfb26e7)

Последовательное сравнение отыскиваемого ключа будет производиться с элементами исходного множества ключей, расположенными в позициях, равных числам Фибоначчи

![image](https://github.com/mireashik/aood_3sem/assets/49165758/d702ce08-1ffa-4ed0-86ed-5c7e28f3d272)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/35714d2c-3cb7-4c23-832c-0747651f33fb)

### 3.1.3. Интерполяционный поиск
- $i$ ‒ номер первого рассматриваемого элемента;
- $j$ ‒ номер последнего рассматриваемого элемента;
- $K$ ‒ отыскиваемый ключ;
- $K_i$ ‒ значение ключа в позиции i;
- $K_j$ ‒ значение ключа в позиции j.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/f038f6ab-a972-42ce-a0a7-1dbee857bcb1)

Требуется найти ключ К=70

![image](https://github.com/mireashik/aood_3sem/assets/49165758/3144a903-450b-4ce0-89dc-2a37ab7a2f27)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/31c47297-4a5d-49d8-93b6-3463b5beb6de)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/4ab8a83f-da9e-49a7-8d99-f98271ed84fa)

Требуется найти ключ К = 90

![image](https://github.com/mireashik/aood_3sem/assets/49165758/d95b1225-7ca6-4057-a8eb-01c10a06fbd3)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/fed00872-d7e5-4f1a-b7e9-d29e290c99fc)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/f542a9d5-ffc6-4dcf-b32d-74a5bb28c11f)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/655312f8-0375-42c1-b6a4-d634b9f47c8f)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/96b6a858-7ba5-4b91-ab82-a067db8be5e8)
