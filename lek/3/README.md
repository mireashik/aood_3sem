## Очереди
### 1.1. Определение очереди
Очередь - противоположность стека. Динамическая структура. Первый доступен (извлекается) первый элемент, «первым пришел – первым ушел» и часто называется структурой **FIFO** (First In – First Out).

![image](https://github.com/mireashik/aood_3sem/assets/49165758/3c35193f-e485-47a8-9ae6-51ba34f2fa14)

Использование:
- вспомогательный инструментарий для программиста
- поиск по графу
- ситуации ожидания (клиенты, вылеты, передача данных)

Все очереди в клавишах, принтеры, очереди данных. Если переходить к АВМиСУ - шина данных та же очередь с приоритетом.
<br>
Головной элемент - первый, хвостовой элемент - последний.

### 1.2. Операции над очередью
Очередь S является абстрактным типом данных, поддерживает 2 следующих основных метода:
1. enqueue (Q, v) - помещает v в конец очереди
2. dequeue (Q) - удаление и возвращение объекта из начала очереди
3. size(Q) - число объектов
4. isEmpty(Q) - проверяет что очередь пуста
5. front(Q) - возвращение первого объекта (голову), не удаляя его
6. Rear Value(Q) - возвращение последнего объекта (хвоста), не удаляя его
7. Clear(Q) - очистка очереди
8. TraverseQueue(Q) - просмотр очереди

### 2.1. Общие вопросы реализации очередей

#### 1. Физическая модель

На основе массива (следим за началом и концом!). Головной элемент - первым, и добавить легко (увеличить счётчик)
<br>
Удаление элемента - смешаем все элементы наверх (от начала до конца, это долго). В ПК на основе массивов очередь лучше не использовать!

#### 2. Линейная реализация

И головной, и хвостовой индексы всегда увеличиваются, но никогда не уменьшаются. Однако когда очередь оказывается пустой, голова и хвост очереди могут быть переустановлены на начало массива.

#### 3. Кольцевые массивы

Неэффективное использование памяти возможно преодолеть

![image](https://github.com/mireashik/aood_3sem/assets/49165758/0680ec60-df9b-42c7-a576-9426e18b3f88)

Если элементы добавляются в очередь и удаляются из нее, голова очереди преследует хвост, перемещаясь по кольцу массива. Змея может ползти бесконечно, оставаясь внутри кольца.

#### 4. Реализация кольцевых массивов
Будут операции по модулю (как счётчик). Или же как часы от 1 до 12, то есть 10 часа + 4 часа = 2 часа. 

#### 5. Граничные условия
Если очередь пуста или полна. Если один элемент, то голова = хвост. Но тогда мы получим что вся очередь будет занята:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/d0567ffb-092a-405c-b935-acb136628bac)

Если вся очередь полна, хвост будет указывать перед головой, то есть позиция будет одинакова. Поэтому индексы использовать нельзя, чтобы отличить пустую очередь от полной.

#### 6. Возможные решения
Есть 3 способа:
1. Одна позиция будет всегда пуста. Очередь полна если хвост находится за 2 позиции до фронтового.
2. Введение новой переменной, булевая или целочисленная которая характеризует полную очередь.
3. Одну индексу присваиваем невозможное значение, например -10000000

#### 7. Обзор реализаций (итоги)
- Физическая модель (линейный массив, головной элемент - 1 позиция, элементы перемещаются по массиву при каждом удалении 1 элемента. Неэффективный метод!)
- Линейный массив с 2 индексами (хорошо если очередь можно очистить разово)
- Кольцевой массив с 1 пустой позицией
- Кольцевой массив с булевой функцией
- Кольцевой массив с целочисленной переменной

### 2.2. Реализация очереди с помощью массива
Массив - первая ячейка следует за последней (кольцо)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/be379f9d-eb4d-44e2-bdd8-0e4e2ace299e)

Для вставки элемента, перемещаем указатель на конец очереди на одну позицию по часовой стрелке, и записать элемент на эту позицию.
<br>
При удалении элемента, перемещаем указатель на начало очереди на одну позицию по часовой стрелке.

Всё ещё не понятно, когда очередь пуста, а когда заполнен весь массив. Это можно понять если указатель `rear` указывает на позицию рядом с `front`, находящимся по часовой стрелке.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/a934ea84-e3aa-4cc1-95bb-c8bd59d40a8e)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/b353c638-6b31-453b-9db8-a07e37795eb5)

Чтобы избежать переполнение "змеи" используем операцию модуля.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/4cb54685-4e28-4e3c-a112-e50c62d9f92f)

Выше видно что началом очереди на рисунке "В" будет элемент 5, хотя 2 не удалён (его уже нет в массиве)!

```python
Алгоритм size():
1 return (N-f+r) mod N

Алгоритм isEmpty():
1 return (f=r)

Алгоритм front():
1 if isEmpty() then
2 вызов QueueEmptyException
3 return Q[f]

Алгоритм dequeue():
1 if isEmpty() then
2 вызов QueueEmptyException
3 temp < Q[f]
4 Q[f] ← null
5 f ← (f + 1) mod N // применяется операция деления по модулю, что позволяет индексировать границы массива
6 return temp

Алгоритм enqueue(o):
1 if size() = N-1 then
2 вызов QueueFullExceptJon
3 О[r] ← o
4 r ← (r+1) mod N
```

Однако фиксированная емкость очереди остаётся (структура то статическая), поэтому рассмотрим пример на динамической структуре.

### 2.3. Реализация очереди с помощью односвязного списка
Процедура `INSERT` производится всегда в конец связного списка.

Реализация очереди упрощается, если использовать для ее представления [связный список с заголовком](https://github.com/mireashik/aood_3sem/tree/main/lek/1#43-разновидности-связных-списков), поскольку в этом случае нет необходимости в выявлении особых случаев.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/423e5e6f-59b4-42bf-9fa3-b55709db19e0)

### 3. Реализация очереди на С++.
В C++ уже есть готовый STL контейнер ‒ queue.

Хотя в стеке присутствует функция peek() (она позволяет обратится к элементу по индексу, подробнее вот здесь), в шаблоне очереди невозможно обратится к определенному элементу. Но если вам нужно иметь доступ ко всем элементам очереди, то можете реализовать очередь через массив.

```c++
#include <iostream>
#include <queue> // Подключили библиотеку queue
using namespace std;

int main() {
    queue<int> q; // Создали очередь q

    cout << "Пользователь, пожалуйста, введите 7 чисел: " << endl;
    
    for (int h = 0; h < 7; h++) {
        int a;
        cin >> a;
        q.push(a); // Добавляем в очередь элементы
    }

    cout << endl;
    cout << "Самый первый элемент в очереди: " << q.front() << endl; // Выводим первый элемент очереди
    q.pop(); // Удаляем элемент из очереди
    cout << "Новый первый элемент (после удаления): " << q.front() << endl;

    if (!q.empty()) {
        cout << "Очередь не пуста!"; // Проверяем, пуста ли очередь (нет)
    }

    system("pause");
    return 0;
}
```

#### Создание очереди с помощью массива
```c++
#include <iostream>

int main() {
    setlocale(LC_ALL, "rus");

    int q[7]; // Создали массив q
    int start = 0, ends = 0; // Создали переменные начала и конца очереди

    cout << "Пользователь, пожалуйста, введите 7 чисел: " << endl;

    for (int h = 0; h < 7; h++) {
        int a;
        cin >> a;
        q[ends++] = a; // Добавляем элементы в очередь (массив)
    }

    cout << "Самый первый элемент в очереди: " << q[start] << endl;
    start++; // Удаляем первый элемент (увеличиваем индекс начала очереди на 1)
    cout << "Новый первый элемент (после удаления): " << q[start] << endl;
    cout << "Самый последний элемент в очереди: " << q[ends - 1]; // Выводим последний элемент очереди

    if (start != ends) {
        cout << "Очередь заполнена!"; // Проверяем, пуста ли очередь
    }

    return 0;
}
```

#### Очередь с приоритетом
Новый элемент добавляется в то место, чтобы очередь была отсортирована по убыванию.
<br>
Самый большой элемент - на 1 месте.

```c++
#include <iostream>
#include <queue>

int main() {
    priority_queue<int> priority_q; // Объявляем приоритетную очередь

    cout << "Введите 7 чисел: " << endl;

    for (int j = 0; j < 7; j++) {
        int a;
        cin >> a;
        priority_q.push(a); // Добавляем элементы в очередь
    }

    cout << "Первый элемент очереди: " << priority_q.top(); // Выводим первый элемент

    return 0;
}
```

#### Создание очереди с помощью списка
```c++
struct list1 {
    type pole1;
    list1 *pole2;
}
struct ch3 {
    list1 *beg, *next ;
}
```

### 4.1. Инфиксные, префиксные и постфиксные выражения

### 4.2. Преобразование инфиксного выражения в префиксное и постфиксное

### 4.3. Обобщённое преобразование из инфиксного в постфиксный вид

### 4.4. Постфиксные вычисления

### 4.5. Выводы

### Задачи на структуры данных
