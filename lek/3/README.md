## Очереди
### 1.1. Определение очереди
Очередь - противоположность стека. Динамическая структура. Первый доступен (извлекается) первый элемент, «первым пришел – первым ушел» и часто называется структурой **FIFO** (First In – First Out).

![image](https://github.com/mireashik/aood_3sem/assets/49165758/3c35193f-e485-47a8-9ae6-51ba34f2fa14)

Использование:
- вспомогательный инструментарий для программиста
- поиск по графу
- ситуации ожидания (клиенты, вылеты, передача данных)

Все очереди в клавишах, принтеры, очереди данных. Если переходить к АВМиСУ - шина данных та же очередь с приоритетом.
<br>
Головной элемент - первый, хвостовой элемент - последний.

### 1.2. Операции над очередью
Очередь S является абстрактным типом данных, поддерживает 2 следующих основных метода:
1. enqueue (Q, v) - помещает v в конец очереди
2. dequeue (Q) - удаление и возвращение объекта из начала очереди
3. size(Q) - число объектов
4. isEmpty(Q) - проверяет что очередь пуста
5. front(Q) - возвращение первого объекта (голову), не удаляя его
6. Rear Value(Q) - возвращение последнего объекта (хвоста), не удаляя его
7. Clear(Q) - очистка очереди
8. TraverseQueue(Q) - просмотр очереди

### 2.1. Общие вопросы реализации очередей

#### 1. Физическая модель

На основе массива (следим за началом и концом!). Головной элемент - первым, и добавить легко (увеличить счётчик)
<br>
Удаление элемента - смешаем все элементы наверх (от начала до конца, это долго). В ПК на основе массивов очередь лучше не использовать!

#### 2. Линейная реализация

И головной, и хвостовой индексы всегда увеличиваются, но никогда не уменьшаются. Однако когда очередь оказывается пустой, голова и хвост очереди могут быть переустановлены на начало массива.

#### 3. Кольцевые массивы

Неэффективное использование памяти возможно преодолеть

![image](https://github.com/mireashik/aood_3sem/assets/49165758/0680ec60-df9b-42c7-a576-9426e18b3f88)

Если элементы добавляются в очередь и удаляются из нее, голова очереди преследует хвост, перемещаясь по кольцу массива. Змея может ползти бесконечно, оставаясь внутри кольца.

#### 4. Реализация кольцевых массивов
Будут операции по модулю (как счётчик). Или же как часы от 1 до 12, то есть 10 часа + 4 часа = 2 часа. 

#### 5. Граничные условия
Если очередь пуста или полна. Если один элемент, то голова = хвост. Но тогда мы получим что вся очередь будет занята:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/d0567ffb-092a-405c-b935-acb136628bac)

Если вся очередь полна, хвост будет указывать перед головой, то есть позиция будет одинакова. Поэтому индексы использовать нельзя, чтобы отличить пустую очередь от полной.

#### 6. Возможные решения
Есть 3 способа:
1. Одна позиция будет всегда пуста. Очередь полна если хвост находится за 2 позиции до фронтового.
2. Введение новой переменной, булевая или целочисленная которая характеризует полную очередь.
3. Одну индексу присваиваем невозможное значение, например -10000000

#### 7. Обзор реализаций (итоги)
- Физическая модель (линейный массив, головной элемент - 1 позиция, элементы перемещаются по массиву при каждом удалении 1 элемента. Неэффективный метод!)
- Линейный массив с 2 индексами (хорошо если очередь можно очистить разово)
- Кольцевой массив с 1 пустой позицией
- Кольцевой массив с булевой функцией
- Кольцевой массив с целочисленной переменной

### 2.2. Реализация очереди с помощью массива
Массив - первая ячейка следует за последней (кольцо)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/be379f9d-eb4d-44e2-bdd8-0e4e2ace299e)

Для вставки элемента, перемещаем указатель на конец очереди на одну позицию по часовой стрелке, и записать элемент на эту позицию.
<br>
При удалении элемента, перемещаем указатель на начало очереди на одну позицию по часовой стрелке.

Всё ещё не понятно, когда очередь пуста, а когда заполнен весь массив. Это можно понять если указатель `rear` указывает на позицию рядом с `front`, находящимся по часовой стрелке.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/a934ea84-e3aa-4cc1-95bb-c8bd59d40a8e)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/b353c638-6b31-453b-9db8-a07e37795eb5)

Чтобы избежать переполнение "змеи" используем операцию модуля.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/4cb54685-4e28-4e3c-a112-e50c62d9f92f)

Выше видно что началом очереди на рисунке "В" будет элемент 5, хотя 2 не удалён (его уже нет в массиве)!

```python
Алгоритм size():
1 return (N-f+r) mod N

Алгоритм isEmpty():
1 return (f=r)

Алгоритм front():
1 if isEmpty() then
2 вызов QueueEmptyException
3 return Q[f]

Алгоритм dequeue():
1 if isEmpty() then
2 вызов QueueEmptyException
3 temp < Q[f]
4 Q[f] ← null
5 f ← (f + 1) mod N // применяется операция деления по модулю, что позволяет индексировать границы массива
6 return temp

Алгоритм enqueue(o):
1 if size() = N-1 then
2 вызов QueueFullExceptJon
3 О[r] ← o
4 r ← (r+1) mod N
```

Однако фиксированная емкость очереди остаётся (структура то статическая), поэтому рассмотрим пример на динамической структуре.

### 2.3. Реализация очереди с помощью односвязного списка
Процедура `INSERT` производится всегда в конец связного списка.

Реализация очереди упрощается, если использовать для ее представления [связный список с заголовком](https://github.com/mireashik/aood_3sem/tree/main/lek/1#43-разновидности-связных-списков), поскольку в этом случае нет необходимости в выявлении особых случаев.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/423e5e6f-59b4-42bf-9fa3-b55709db19e0)

### 3. Реализация очереди на С++.
В C++ уже есть готовый STL контейнер ‒ queue.

Хотя в стеке присутствует функция peek() (она позволяет обратится к элементу по индексу, подробнее вот здесь), в шаблоне очереди невозможно обратится к определенному элементу. Но если вам нужно иметь доступ ко всем элементам очереди, то можете реализовать очередь через массив.

```c++
#include <iostream>
#include <queue> // Подключили библиотеку queue
using namespace std;

int main() {
    queue<int> q; // Создали очередь q

    cout << "Пользователь, пожалуйста, введите 7 чисел: " << endl;
    
    for (int h = 0; h < 7; h++) {
        int a;
        cin >> a;
        q.push(a); // Добавляем в очередь элементы
    }

    cout << endl;
    cout << "Самый первый элемент в очереди: " << q.front() << endl; // Выводим первый элемент очереди
    q.pop(); // Удаляем элемент из очереди
    cout << "Новый первый элемент (после удаления): " << q.front() << endl;

    if (!q.empty()) {
        cout << "Очередь не пуста!"; // Проверяем, пуста ли очередь (нет)
    }

    system("pause");
    return 0;
}
```

#### Создание очереди с помощью массива
```c++
#include <iostream>

int main() {
    setlocale(LC_ALL, "rus");

    int q[7]; // Создали массив q
    int start = 0, ends = 0; // Создали переменные начала и конца очереди

    cout << "Пользователь, пожалуйста, введите 7 чисел: " << endl;

    for (int h = 0; h < 7; h++) {
        int a;
        cin >> a;
        q[ends++] = a; // Добавляем элементы в очередь (массив)
    }

    cout << "Самый первый элемент в очереди: " << q[start] << endl;
    start++; // Удаляем первый элемент (увеличиваем индекс начала очереди на 1)
    cout << "Новый первый элемент (после удаления): " << q[start] << endl;
    cout << "Самый последний элемент в очереди: " << q[ends - 1]; // Выводим последний элемент очереди

    if (start != ends) {
        cout << "Очередь заполнена!"; // Проверяем, пуста ли очередь
    }

    return 0;
}
```

#### Очередь с приоритетом
Новый элемент добавляется в то место, чтобы очередь была отсортирована по убыванию.
<br>
Самый большой элемент - на 1 месте.

```c++
#include <iostream>
#include <queue>

int main() {
    priority_queue<int> priority_q; // Объявляем приоритетную очередь

    cout << "Введите 7 чисел: " << endl;

    for (int j = 0; j < 7; j++) {
        int a;
        cin >> a;
        priority_q.push(a); // Добавляем элементы в очередь
    }

    cout << "Первый элемент очереди: " << priority_q.top(); // Выводим первый элемент

    return 0;
}
```

#### Создание очереди с помощью списка
```c++
struct list1 {
    type pole1;
    list1 *pole2;
}
struct ch3 {
    list1 *beg, *next ;
}
```

### 4.1. Инфиксные, префиксные и постфиксные выражения
Инфиксные формы (типа B * C), оператор находится между 2 операндами.

В примере типа A + B * C проблема - нужно ввести приоритет. 

Префиксные формы (типа +A B) операторы перед значениями с которыми работают.
<br>
Постфискые формы (типа A B +) операторы после значений.

Скобки в этих 2 формах не нужны! Примеры одинаковых операций ниже:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/80879469-2c65-4643-800b-95c5b58edf1f)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/b126fc93-546c-4fa2-ab58-6b7c38a149c5)

### 4.2. Преобразование инфиксного выражения в префиксное и постфиксное
![image](https://github.com/mireashik/aood_3sem/assets/49165758/4df76a2a-74d7-491c-b627-0464313cf8e0)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/1f934c8b-e171-425c-b6b7-71c50f45174a)

Полная расстановка скобок поможет нам преобразовать. Оператор передвигается на крайнюю левую или крайнюю правую позицию.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/a29ea2f1-4811-4d34-99ee-eab5cce08f18)

### 4.3. Обобщённое преобразование из инфиксного в постфиксный вид
Храник операторы в стеке. На вершине - последний сохранённый оператор. 

1. Создать пустой стек для хранения операторов / вывода
2. Инфиксная строка -> список
3. Если токен операнд - добавляем в конец списка
4. Если токен левая скобка - положить в стек
5. Если токен правая скобка - выталкиваем элементы из стека, до левой скобки, добавляем операторы в конец списка
6. Если токен оператор - добавляем его в стек, вытолкнуть любой оператор из стека (если он имеет больший приоритет), и добавить его в список
7. Оставшиеся операторы добавляем в список

![image](https://github.com/mireashik/aood_3sem/assets/49165758/dbfd83d0-bcf2-4bfd-9e6d-99866cb569a6)

### 4.4. Постфиксные вычисления
Если нужно посчитать выражения, то используем стек и сканируем операнды. Если умножение - выталкиваем 2 символа и перемножаем, после помещаем его в стек и ищем следующий оператор +. После суммируем 2 элемента и вытаскиваем последний элемент как результат выраженияю

![image](https://github.com/mireashik/aood_3sem/assets/49165758/b55152da-3ae8-4fd1-83e5-3d45d9c1ca8f)

Однако нужно быть осторожным с делением (ибо 15 / 5 это не тоже самое что 5 / 15), операнды должны выталкиваться в обратной последовательности

![image](https://github.com/mireashik/aood_3sem/assets/49165758/03c7cf41-1f47-4f38-acc8-1368c46aa626)

### 4.5. Выводы
Вычисление значения выражения по его префиксной записи. Алгоритм вычисления полностью совпадает с алгоритмом вычисления по постфиксной записи, но префиксная строка сканируется справа налево.

### Задачи на структуры данных
Есть 1 пирамидка с дисками разного размера. Есть ещё 2 пустые пирамидки. Надо переместить диски с одной пирамидки на другую. Перекладывать можно только по одному диску за ход. Складывать диски можно только меньший на больший. Необходимо переложить все диски на вторую пирамидку.

Тут одна функция, она рекурсивно вызывает сама себя - подразумевается что первый (он же А) столбец - откуда, второй (он же Б) - куда, третий (он же С)- вспомогательный. Получается мы поочередно перекладываем сначала маленькую пирамидку, потом большую, как на картинке.

```c++
#include <iostream>
#include <stack>

using namespace std;

stack<int> first, second, third; // Объявление переменных типа стек по целочисленному шаблону

void hanoi(int num, stack<int>& a, stack<int>& b, stack<int>& c) {
    // Функция для решения головоломки Ханой с использованием стеков
    // num - количество дисков
    // a, b, c - три штыря

    if (num != 0) {
        // Если число учтенных дисков не равно нулю
        hanoi(num - 1, a, c, b);
        // Рекурсивный вызов функции с уменьшенным количеством учтенных дисков и другим порядком

        cout << first.top() << " - " << second.top() << " - " << third.top() << endl;
        // Вывод текущего состояния верхушки стеков

        b.push(a.top());
        // Внесение в стек значения диска с другого штыря
        a.pop();
        // Удаление внесенного диска со штыря

        hanoi(num - 1, c, b, a);
        // Рекурсивный вызов функции с уменьшенным количеством учтенных дисков и другим порядком
    }
}

int main() {
    // Основная часть программы
    int num_disks;
    // Количество дисков

    cout << "Введите количество дисков: ";
    cin >> num_disks;

    // Инициализация первого стека дисками
    for (int i = num_disks; i >= 1; i--) {
        first.push(i);
    }

    // Вызов функции Ханой для перемещения дисков с первого штыря на третий
    hanoi(num_disks, first, third, second);

    return 0;
}
```

```c++
#include <iostream>
#include <stack>

using namespace std;

int main() {
    // Инициализация штырей и добавление основания
    stack<int> first, second, third;
    first.push(0); // Добавляем основание для корректного отображения
    second.push(0);
    third.push(0);

    // Заполняем первую пирамиду дисками (числами по порядку для удобства)
    first.push(5); 
    first.push(4);
    first.push(3);
    first.push(2);
    first.push(1);

    int num = first.size() - 1; // Вычисляем первичное количество учтенных дисков

    cout << "== Начало работы ==" << endl;
    cout << first.size() - 1 << "-items " << second.size() - 1 << "-items " << third.size() - 1 << "-items " << endl;
    // Вывод информации о количестве дисков на штырях за исключением диска с основанием

    cout << "== Начало перестановок ==" << endl;

    // Вызов функции переноса дисков
    hanoi(num, first, second, third);

    cout << first.top() << " - " << second.top() << " - " << third.top() << endl;

    cout << "== Окончание перестановок ==" << endl;
    cout << first.size() - 1 << "-items " << second.size() - 1 << "-items " << third.size() - 1 << "-items " << endl;

    cout << "== Конец работы ==" << endl;

    return 0;
}
```

На складе хранятся контейнеры с товарами N различных видов. Все контейнеры составлены в N стопок. В каждой стопке могут находиться контейнеры с товарами любых видов (стопка может быть изначально пустой). Автопогрузчик может взять верхний контейнер из любой стопки и поставить его сверху в любую стопку. Необходимо расставить все контейнеры с товаром первого вида в первую стопку, второго вида – во вторую стопку и т.д. Программа должна вывести последовательность действий автопогрузчика или сообщение о том, что задача решения не имеет.

Словесное описание решения.
Для начала заметим, что мы можем работать только с одним ящиком в каждой стопке – самым верхним. Мы можем снимать самый верхний ящик или класть наверх стопки другой ящик. Такая структура данных, в которой работать можно только с одним верхним элементом называются СТЕКОМ.

Итак, задачу можно переформулировать следующим образом: Дано n стеков, заполненных числами от 1 до n. Разрешается перекладывать элементы из одного стека в другой. Необходимо разложить все числа по стекам правильным образом (все числа равные k необходимо собрать в стеке с номером k) или определить, что задача решения не имеет.

Если n = 1, то ничего перекладывать не надо, задача уже решена.
<br>
Если n = 2, то задача имеет решение только в следующих двух возможных случаях (стеки изображены растущими слева направо, то есть самый верхний элемент в стеке является самым правым):
<br>
Стек 1: 1 1 ... 1 2 2 ... 2
<br>
Стек 2: 2 2 ... 2

Или

Стек 1: 1 1 ... 1
<br>
Стек 2: 2 2 ... 2 1 1 ... 1

В первом случае необходимо переложить все ящики вида 2 из стека 1 в стек 2, во втором случае необходимо переложить все ящики вида 1 из стека 2 в стек 1. При этом количество элементов в каждой из групп, изображённых на рисунке (то есть каждой группы, содержащей многоточие) может быть произвольным, в том числе может равняться нулю. Во всех остальных случаях при n = 2 решения нет.

Если же n > 2 то решение есть всегда. Для этого достаточно привести какой-нибудь конструктивный алгоритм решающий поставленную задачу. Рассмотрим один из возможных алгоритмов на следующем примере для n = 5:

Стек 1: 1 5 2
<br>
Стек 2: 2 1 4
<br>
Стек 3: 3 5 4
<br>
Стек 4: 5 2 1
<br>
Стек 5: 3 5 2

Сначала соберём все числа в стек 1: переложим все числа из стека 2 в стек 1, затем из стека 3 в стек 1 и т. д. Получим такую картинку:

Стек 1: 1 5 2 4 1 2 4 5 3 1 2 5 2 5 3
Стек 2:
<br>
Стек 3:
<br>
Стек 4:
<br>
Стек 5:

Теперь будем извлекать элементы по одному из стека 1 и класть каждый элемент в стек, соответствующий ему номеру. При этом если из стека был извлечён элемент номер 1 мы будем класть его в стек номер 2. После окончания этой процедуры стек номер 1 будет пустым, в стеке номер 2 будут находиться элементы, равные 1 или 2, а в стеках номер 3..n будут находится элементы, равные номеру стека:

Стек 1:
<br>
Стек 2: 2 2 1 2 1 2 1
<br>
Стек 3: 3 3
<br>
Стек 4: 4 4
<br>
Стек 5: 5 5 5 5

Теперь будем извлекать элементы из стека 2, элементы, равные 1 будем класть в стек 1, а элементы, равные 2 – в стек 3:

Стек 1: 1 1 1
<br>
Стек 2:
<br>
Стек 3: 3 3 2 2 2 2
<br>
Стек 4: 4 4
<br>
Стек 5: 5 5 5 5

Для полного решения задачи осталось переложить все верхние элементы, равные 2 из стека 3 в стек 2:

Стек 1: 1 1 1
<br>
Стек 2: 2 2 2 2
<br>
Стек 3: 3 3
<br>
Стек 4: 4 4
<br>
Стек 5: 5 5 5 5

```c++
#include <iostream>
#include <stack>
#include <cstdlib>
#include <time.h>

using namespace std;

int N, M; // размер массива количество площадок
bool not_sorted = false;

void how_much_on_pad(stack<int> a[]) {
    // Функция для вывода количества контейнеров на каждой площадке
    for (int i = 0; i < N; i++) {
        cout << "|_ " << a[i].size() << " _";
    }
    cout << "| " << endl;
}

int main() {
    srand(time(0));

    cout << "Введите целое число (количество площадок): ";
    cin >> N; // получение от пользователя количества площадок под контейнеры
    cout << "Введите целое число (количество товара): ";
    cin >> M; // получение от пользователя количества контейнеров

    stack<int> *container_pad = new stack<int>[N]; // Выделение памяти для массива стеков

    for (int i = 0; i < M; i++) {
        // случайным образом заполняем площадки контейнерами
        container_pad[rand() % N].push(rand() % N);
    }

    how_much_on_pad(container_pad); // смотрим, как заполнилась площадка

    if (N == 1) {
        cout << "Весь товар лежит на единственной площадке!" << endl;
    } else {
        if (N == 2) {
            // Если площадок две - могут возникнуть сложности при переносе контейнеров
            while (container_pad[0].top() != 0 && container_pad[1].top() != 1) {
                // работаем пока сверху 0 и 1 стопки лежат чужие контейнеры
                if (container_pad[0].top() != 0 && container_pad[1].top() == 1) {
                    container_pad[1].push(container_pad[0].top());
                    container_pad[0].pop();
                } else {
                    if (container_pad[0].top() == 0 && container_pad[1].top() != 1) {
                        container_pad[0].push(container_pad[1].top());
                        container_pad[1].pop();
                    } else {
                        cout << "" << endl;
                        break;
                    }
                }
            }
        } else {
            for (int i = 1; i < N; i++) {
                // переносим все на первую площадку (нулевая площадка)
                while (!container_pad[i].empty()) {
                    container_pad[0].push(container_pad[i].top());
                    container_pad[i].pop();
                }
            }
            how_much_on_pad(container_pad); // смотрим, как заполнена площадка - весь товар на первой площадке

            while (!container_pad[0].empty()) {
                // проверяем товар и отвозим на площадку, где он должен лежать
                if (container_pad[0].top() != 0) {
                    // если ящик не 0 товар, то перекладываем в соответствующую стопку
                    container_pad[container_pad[0].top()].push(container_pad[0].top());
                    container_pad[0].pop();
                } else {
                    // если товар нулевой, перекладываем в стопку 1
                    not_sorted = true;
                    container_pad[1].push(container_pad[0].top());
                    container_pad[0].pop();
                }
            }

            while (not_sorted) {
                // проверяем стопку 1 на наличие нулевых
                if (container_pad[1].top() == 0) {
                    // отправляем 0 товар в свою стопку
                    container_pad[0].push(container_pad[1].top());
                    container_pad[1].pop();
                } else {
                    // отправляем 1 товар в 2 стопку
                    container_pad[2].push(container_pad[1].top());
                    container_pad[1].pop();
                }
            }

            while (not_sorted) {
                // разбираем 2 стопку
                if (container_pad[2].top() == 2) {
                    // если нашли 2 товар из 2 стопки – завершаем
                    not_sorted = false;
                } else {
                    // если нашли 1 товар возвращаем его в 1 стопку
                    container_pad[1].push(container_pad[2].top());
                    container_pad[2].pop();
                }
            }
        }
    }

    how_much_on_pad(container_pad); // смотрим, как в итоге заполнена площадка
    delete[] container_pad; // очистка памяти
    return 0;
}
```
