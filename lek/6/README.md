## Дерево поиска
С числом ветвей > 2 – часто такие деревья называют мультивариантными (многопутевыми, сильноветвящимися) или K-деревьями (K-мерными). B-деревья (различные деревья Байера-МакКрейта с вариантами, например, 2-3-деревья, 2-3-4-деревья) и тому подобное.

- сбалансированное дерево (уровень в левом и правом поддереве различаются либо на 0, либо на 1)
- идеально сбалансированное (число вершин в левом и правом поддеревьях различается не более чем на 1)
- вырожденное (каждый уровень - 1 вершина)
- остов дерево графа (дерево, подграф данного графа, с тем же числом вершин, что и у исходного графа)

Автоматическая балансировка дерева выполняется, например, для АВЛ-деревьев, красно-черных деревьев

### 1.2 Двоичные деревья поиска
**Пирамида** («куча, сортирующее дерево поиска») – значения всех узлов, размещённых на 1 уровне, больше (или меньше) значений узлов, размещенных на вышележащем уровне

![image](https://github.com/mireashik/aood_3sem/assets/49165758/e2eb069d-747d-4971-944e-8cf977f4a51f)

Обладает 3 условиями:
1. Значение в любой вершине не меньше, чем значения её потомков.
2. Глубина всех листьев (расстояние до корня) отличается не более чем на 1 слой.
3. Последний слой заполняется слева направо без «дырок».

Двоичное дерево поиска - значения всех узлов, правее некоторого узла, больше значений узлов, размещенных левее

![image](https://github.com/mireashik/aood_3sem/assets/49165758/4276579a-c5d9-43f4-b7d1-ca8ba106d2ef)

В дальнейшем под двоичными деревьями будут подразумеваться именно двоичные деревья поиска.

Структура пирамиды и дерева практически одинакова, отличаются только характером размещения данных.

В чём отличие бинарных деревьев от двусвязного списка? Бывают случаи, когда они ничем не отличаются. Более того, могут не отличаться не только от двусвязного списка, но и от односвязного списка
<br>
основное отличие – у списка соседними являются предшествующий и последующий элементы, и структура линейна
<br>
У бинарного дерева поиска же соседними являются элементы с меньшим и большим ключом, и структура ветвящаяся – в виде  дерева

![image](https://github.com/mireashik/aood_3sem/assets/49165758/c7fa72c2-2354-4d5e-b021-ad463c23ab1a)

Однако память - линейна, узел дерева хранится в памяти так:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/9a83ba7c-f230-499c-b4ea-9c0d72d2a50c)

Двоичное дерево в памяти:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/e37dad87-1755-4b52-a488-d5dce642740f)

Ещё раз вспомним о листе, высоте дерева

Области применения деревьев: 
- для хранения информации, как таковой
- в процедурах поиска и сортировки
- для описания хранения файлов на дисковых носителях
- при построении эффективных кодов для сжатия информации (коды Шеннона–Фано и Хаффмена). 

Если дерево отсортировано (а это дерево именно такое), то операция поиска выполняется быстро, с эффективностью, близкой к эффективности двоичного поиска.

#### Выводы
Бинарное дерево – иерархическая структура данных, в которой каждый узел имеет значение (иногда оно является и ключом), а также ссылки на левого и правого потомка.
<br>
Узел на самом верхнем уровне - корень. Узлы, не имеющие потомков - лист.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/f72d1943-e0f6-4a99-af06-742d4b4d61fa)

Дополнительные свойства бинарного дерева поиска:
- значение левого потомка меньше значения родителя
- значение правого потомка больше значения родителя для каждого узла дерева

То есть, данные в бинарном дереве поиска хранятся в отсортированном виде. Поиск также идёт по правилам и строгому порядку, отсортированный вид при удалении узла не нарушается.

### 1.3 Операции с двоичными деревьями поиска
- добавление элемента
- удаление
- прохождение (просмотр)
- поиск элементов
- принудительной балансировки
- подсчета числа узлов в дереве
- измерения высоты дерева
- поиска ближайшего общего корня

При балансировке деревьев используются операции поворотов (вращений), простых и двойных, левых и правых.

#### 1.3.1 Добавление узла в дерево
Последовательно строим

![image](https://github.com/mireashik/aood_3sem/assets/49165758/671813c4-e99f-421a-b8da-df1184209c7f)

При поступлении записи с ключом k, ключ сравнивают, начиная с корня, с ключом очередного узла. В зависимости от результата сравнения, процесс продолжают в левой или правой ветви пока не будет достигнут один из узлов, с которым можно связать входящую запись.

```c++
// Функция для добавления узла в бинарное дерево поиска
// Принимает указатели на корень дерева (tree), текущий узел (r), предыдущий узел (prev) и данные для нового узла (buf)
void add_node(node*& tree, node*& r, node*& prev, node& buf) 
{
    // Если текущий узел r равен NULL, создаем новый узел
    if (r == NULL) 
    { 
        r = new node; // Выделяем память под новый узел
        r->left = NULL; // Инициализируем указатель на левое поддерево как NULL
        r->right = NULL; // Инициализируем указатель на правое поддерево как NULL
        r->key = buf.key; // Копируем ключ из данных buf в текущий узел
        r->data = buf.data; // Копируем данные из buf в текущий узел

        // Если дерево не пусто и предыдущий узел не равен текущему узлу r,
        // то определяем, является ли r левым или правым потомком предыдущего узла prev
        if (tree != r) 
            if (buf.key < prev->key) 
                prev->left = r; // Если ключ меньше, чем ключ предыдущего узла, устанавливаем r как левого потомка
            else 
                prev->right = r; // Иначе устанавливаем r как правого потомка

        return; // Возвращаемся из функции после добавления нового узла
    } 

    // Если ключ данных для нового узла меньше ключа текущего узла,
    // рекурсивно вызываем add_node для левого поддерева
    if (buf.key < r->key) 
        add_node(tree, r->left, r, buf); 
    else 
        // Иначе рекурсивно вызываем add_node для правого поддерева
        add_node(tree, r->right, r, buf); 
}
```

#### 1.3.2 Прохождение дерева
может выполняться с разными целями: 
- просмотр (вывод на дисплей)
- сохранение в файл
- поиск

Прохождение дерева может выполняться по методам:
- «в глубину»
- «в ширину»

Существует три способа прохождения дерева в ГЛУБИНУ:
1. Последовательный (он же инфиксный, симметричный, поперечный) – дерево проходится, начиная с левой ветви вверх к корню, затем к правой ветви.
2. Нисходящий (префиксный или прямой) – от корня к левой ветви, затем к правой.
3. Восходящий (постфиксный или обратный) – проходится левая ветвь, затем правая, затем корень.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/4f335f3d-ed38-4b6f-9ace-37d949f57bef)

Последовательный способ удобен для сортировки данных.
<br>
Нисходящий способ удобен для сохранения дерева 
<br>
Восходящий обход может использоваться при полном удалении всего дерева

```c++
// Функция для обхода дерева поиска в порядке "Inorder"
// Принимает указатель на текущий узел (r)
void inorder(node* r) 
{
    // Если текущий узел r равен NULL, завершаем рекурсию
    if (r == NULL)
        return;

    // Рекурсивный вызов для левого поддерева
    inorder(r->left);

    // Выводим ключ текущего узла
    cout << r->key << " ";

    // Рекурсивный вызов для правого поддерева
    inorder(r->right);
}

// Функция для обхода дерева поиска в порядке "Preorder"
// Принимает указатель на текущий узел (r)
void preorder(node* r)
{
    // Если текущий узел r равен NULL, завершаем рекурсию
    if (r == NULL)
        return;

    // Выводим ключ текущего узла
    cout << r->key << " ";

    // Рекурсивный вызов для левого поддерева
    preorder(r->left);

    // Рекурсивный вызов для правого поддерева
    preorder(r->right);
}

// Функция для обхода дерева поиска в порядке "Postorder"
// Принимает указатель на текущий узел (r)
void postorder(node* r) 
{
    // Если текущий узел r равен NULL, завершаем рекурсию
    if (!r)
        return;

    // Рекурсивный вызов для левого поддерева
    postorder(r->left);

    // Рекурсивный вызов для правого поддерева
    postorder(r->right);

    // Выводим ключ текущего узла
    cout << r->key << " ";
}
```

Обход бинарного дерева поиска в ШИРИНУ выполняется с помощью вспомогательной структуры данных – очереди или стека. 

![image](https://github.com/mireashik/aood_3sem/assets/49165758/cd622f4d-58cb-44cd-8e80-2b8ebbe58bcd)

Результат обхода дерева, показанного на рисунке 9 с выводом содержимого узлов на экран, следующий: d b f a c e g

```c++
// Структура для представления списка узлов
struct Link2
{
    node* n;         // Узел дерева
    Link2* next, *prev;  // Указатели на следующий и предыдущий узлы в списке
};

// Функция вставки узла в список
// Принимает указатель на предыдущий узел (Pred) и данные для нового узла (data)
void Insert2(Link2* Pred, node* data)
{
    // ...

    Loc->n = data; // Ввод узла дерева в список

    // ...

    // Обычные операции вставки в список

    // ...
}

// Функция извлечения узла из очереди
// Принимает указатель на узел в списке (Del)
// Возвращает указатель на извлеченный узел дерева
node* Retrieve2(Link2* Del)
{
    node* a = Del->n;
    Delete2(Del); // Предполагается, что функция Delete2 удаляет узел из списка

    return a;
}

// Функция обхода дерева в ширину
// Принимает указатель на корень дерева (r)
void WidthTraverse(node* r)
{
    if (!r)
        return;

    // Создание локальной очереди
    Link2* L2 = new Link2;

    // Инициализация указателей очереди на саму себя (пустая очередь)
    L2->next = L2;
    L2->prev = L2;

    // Занесение корневого узла в очередь
    Insert2(L2->prev, r);

    // Пока очередь не пуста
    while (L2->prev != L2)
    {
        // Извлечение узла из очереди
        node* cur = Retrieve2(L2->next);

        // Вывод ключа текущего узла
        printf("%d ", cur->key);

        // Если есть левый потомок, добавляем его в очередь
        if (cur->left)
            Insert2(L2->prev, cur->left);

        // Если есть правый потомок, добавляем его в очередь
        if (cur->right)
            Insert2(L2->prev, cur->right);
    }

    // Освобождение памяти, занятой под очередь
    delete L2;
}
```

Следует отметить, что дерево может быть организовано не только как динамическая связная структура данных, но и как массив.
<br>
Например, при НИСХОДЯЩЕМ обходе начальный элемент массива оказывается КОРНЕМ дерева, а при ПОСЛЕДОВАТЕЛЬНОМ обходе – самым ЛЕВЫМ узлом (рисунок 9). 

Дерево Фенвика (двоичное индексированное дерево) – структура данных, позволяющая быстро изменять значения в массиве и находить некоторые функции от элементов

#### 1.3.3 Поиск узла в дереве
Поиск узла в дереве (в том числе в бинарном дереве поиска) может выполняться по такому же принципу, что и просмотр дерева. 

- ИЛИ использовать рекурсивные функции, например, с использованием  рассмотренных выше функций inorder, preorder
- ИЛИ отказаться от рекурсии.

```c++
// Рекурсивная функция поиска узла с ключом skey в дереве
// Принимает указатель на текущий узел (r), ключ для поиска (skey) и указатель на найденный узел (f)
void poisk1(node* r, int skey, node*& f) 
{
    // Если текущий узел r равен NULL или узел уже найден (f != NULL), завершаем рекурсию
    if (r == NULL || f)
        return;

    // Если ключ текущего узла r равен искомому ключу skey
    if (r->key == skey) 
    {
        f = r; // Устанавливаем указатель на найденный узел
        return; // Выходим из функции, так как узел найден
    } 
    else 
    {
        // Если искомый ключ меньше ключа текущего узла, рекурсивно вызываем поиск для левого поддерева
        if (skey < r->key) 
            poisk1(r->left, skey, f); 
        else
            // Иначе рекурсивно вызываем поиск для правого поддерева
            poisk1(r->right, skey, f);
    }
}
```

Третий аргумент node*& f – одновременно узел, в котором находятся найденные данные, и признак успеха поиска. 

Рекурсивные функции обладают одним недостатком: возможностью переполнения стека возврата из подпрограмм при большом количестве рекурсивных вызовов (а это может произойти при большом размере структуры данных).

Поиск с использованием нерекурсивной процедуры:

```c++
// Функция поиска узла с ключом skey в дереве с использованием цикла while
// Принимает указатель на текущий узел (r), ключ для поиска (skey) и указатель на найденный узел (f)
void poisk2(node* r, int skey, node*& f) 
{ 
    // Пока текущий узел r не равен NULL и узел еще не найден (f == NULL)
    while (r != NULL && f == NULL)
    {
        // Если ключ текущего узла r равен искомому ключу skey
        if (r->key == skey)
        {
            f = r; // Устанавливаем указатель на найденный узел
            return; // Выходим из функции, так как узел найден
        } 
        else 
        {
            // Если искомый ключ меньше ключа текущего узла, переходим к левому потомку
            if (skey < r->key)
                r = r->left; 
            else 
                // Иначе переходим к правому потомку
                r = r->right; 
        }
    }
}
```

Используя поиск узла, можно заменить рекурсивную процедуру добавления узла на нерекурсивную.
<br>
Для сбалансированного дерева, изображенного на рисунке 10, поиск аналогичен двоичному дереву – то есть, нужно просмотреть не более log2N узлов.

**Сбалансированное** двоичное дерево поиска - высота каждого из поддеревьев, имеющих общий корень, отличается не более чем на некоторую константу k

![image](https://github.com/mireashik/aood_3sem/assets/49165758/8a454aa4-fc43-4ef4-8883-1a0f5e1706cd)

Для вырожденного дерева (рисунок 11) поиск аналогичен поиску в односвязном списке – в среднем нужно просмотреть половину узлов, а в худшем случае – все N узлов.

**Вырожденное** дерево - каждый узел имеет 1 сына. Вырожденное бинарное дерево эквивалентно связанному списку

![image](https://github.com/mireashik/aood_3sem/assets/49165758/174bb724-491e-451a-b830-3d17d165bb45)

#### 1.3.4 Удаление узла из дерева
Удаление узла из дерева – существенно более сложный процесс, чем поиск. Наиболее простым случаем является удаление терминального узла.

Такой узел всегда существует. Это либо самый ЛЕВЫЙ узел правой ветви, либо самый ПРАВЫЙ узел левой ветви.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/7dc233b4-8b5b-45b1-ac4f-1ec024772cdf)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/a37f20e2-eeb3-4a61-9be7-36b9b333f187)

Процедура удаления узла должна различать три случая: 
1. Узла с данным ключом в дереве нет.
2. Узел с заданным ключом имеет не более одной ветви (рисунок 12)
3. Узел с заданным ключом имеет две ветви (рисунок 13)

```c++
// Вспомогательная функция для удаления узла с одним поддеревом
// Принимает указатели на текущий узел (r) и узел для переноса данных (q)
void del1(node*& r, node*& q) 
{ 
    // Если у текущего узла r нет правого поддерева
    if (r->right == NULL) 
    { 
        q->key = r->key; // Переносим данные
        q->data = r->data; 
        q = r; // Указатель q теперь указывает на узел, который нужно удалить
        r = r->left; // Устанавливаем левого потомка вместо удаляемого узла
    } 
    else
    {
        // Рекурсивно вызываем del1 для правого поддерева
        del1(r->right, q);
    }
}

// Функция удаления узла с ключом key из дерева
// Принимает указатель на корень дерева (d) и ключ для поиска (key)
void del_node(node*& d, int key)
{ 
    node* q; // Вспомогательный указатель для удаления
    // Если текущий узел d равен NULL, завершаем функцию
    if (d == NULL) 
        return; 
    else 
        // Если искомый ключ меньше ключа текущего узла, рекурсивно вызываем del_node для левого поддерева
        if (key < d->key) 
            del_node(d->left, key); 
        else if (key > d->key) // Иначе, если искомый ключ больше ключа текущего узла
            del_node(d->right, key); 
        else // Иначе искомый ключ совпадает с ключом текущего узла
        { 
            q = d; // Устанавливаем вспомогательный указатель q на удаляемый узел
            // Если у удаляемого узла нет правого поддерева
            if (q->right == NULL) 
                d = q->left; // Устанавливаем левого потомка вместо удаляемого узла
            else 
                // Если у удаляемого узла нет левого поддерева
                if (q->left == NULL) 
                    d = q->right; // Устанавливаем правого потомка вместо удаляемого узла
                else 
                    // Иначе вызываем del1 для удаления узла с двумя поддеревьями
                    del1(q->left, q); 
            delete q; // Удаляем узел
        } 
}
```

#### 1.3.5 Удаление всех узлов дерева
Эта операция выполняется по тому же принципу, что и просмотр дерева. Для этого случая можно использовать восходящий обход дерева. Восходящий (постфиксный или обратный) – проходится левая ветвь, затем правая, затем 
корень.

```c++
// Рекурсивная функция для удаления всех узлов в бинарном дереве
// Принимает указатель на корень дерева (r)
void del_all(node*& r) 
{ 
    // Если текущий узел r равен NULL, завершаем рекурсию
    if (!r)
        return; 

    // Рекурсивно вызываем del_all для левого поддерева
    del_all(r->left); 

    // Рекурсивно вызываем del_all для правого поддерева
    del_all(r->right); 

    // Удаляем текущий узел
    delete r;

    // Устанавливаем указатель на NULL для предотвращения использования удаленного узла
    r = NULL;
}
```

#### 1.3.6 Подсчёт узлов
Эта операция так же выполняется по тому же принципу, что и просмотр дерева. Только для этого случая необходимо воспользоваться нисходящим обходом дерева. Нисходящий (префиксный или прямой) – от корня к левой ветви, затем к правой.

```c++
// Рекурсивная функция для подсчета числа узлов в бинарном дереве
// Принимает указатель на текущий узел (r) и переменную для хранения результата (p)
void Nnodes(node* r, int& p) 
{ 
    // Если текущий узел r равен NULL, завершаем рекурсию
    if (r == NULL) 
        return; 

    // Увеличиваем счетчик узлов
    p++; 

    // Рекурсивно вызываем Nnodes для левого поддерева
    Nnodes(r->left, p); 

    // Рекурсивно вызываем Nnodes для правого поддерева
    Nnodes(r->right, p); 
}
```

#### 1.3.7 Определение высоты дерева
При подсчете числа уровней используется тот же принцип, что и при просмотре дерева.

```c++
// Рекурсивная функция для определения высоты бинарного дерева
// Принимает указатель на текущий узел (r), текущую высоту (p) и переменную для хранения результата (h)
void Height(node* r, int p, int& h) 
{ 
    // Если текущий узел r равен NULL, завершаем рекурсию
    if (r == NULL) 
        return; 

    // Увеличиваем текущую высоту
    p++; 

    // Проверяем, является ли текущий узел терминальным (листом)
    if (r->left == NULL && r->right == NULL)
    {
        // Если текущая высота больше текущей максимальной высоты, обновляем максимальную высоту
        if (p > h) 
            h = p; 
    }

    // Рекурсивно вызываем Height для левого поддерева
    Height(r->left, p, h); 

    // Рекурсивно вызываем Height для правого поддерева
    Height(r->right, p, h); 
}
```

Во многих алгоритмах обработки данных, хранящихся в деревьях, предполагается, что ключи узлов должны быть уникальными, иными словами, неповторяющимися.
<br>
На самом деле процедуры обработки дерева допускают существование повторяющихся ключей. Следует только помнить может быть найден не тот узел, который требовался, а первый встреченный узел с указанным ключом.

### 2. Дерево выражений
Бинарное дерево выражений - это бинарное дерево, чьи листья являются операндами, такими как константы или имена переменных, а другие узлы содержат операторы.

Например, постфиксная запись a b + c d e + * * приводит к следующему дереву выражений. 
<br>
Соответствующее инфиксное обозначение (a+b)*(c*(d+e)) может быть получено путем обхода дерева выражений

![image](https://github.com/mireashik/aood_3sem/assets/49165758/422c1b49-ff96-40fc-afcb-fa6c21ab25ae)

дерево выражений для 3 + ((5+9)*2) было бы:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/19cb8350-296e-4f9e-90a5-048456f4bc88)

Дерево выражений состоит из двоичных выражений. Но для унарного оператора одно поддерево будет пустым

Построение дерева выражений:
- Анализ и предоставление постфиксного выражения, для которого программа построит дерево выражений.
- Порядок обхода двоичного дерева/дерева выражений обеспечит инфиксное выражение данного ввода.

- Входные данные: A B C * + D/ - постфиксного выражения, для которого необходимо построить дерево выражений.
- Вывод: A + B * C / D – инфиксное выражение данного ввода.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/203f4fe0-7e5f-4ac4-bf33-3e58152c929a)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/5512e43c-c7c1-4d1d-89ca-a3cdb2783cfd)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/80492154-18a7-41e3-a524-0d72a410082b)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/f8c1700f-4a94-48e1-9d11-cf0119508fb1)

```c++
#include <bits/stdc++.h>
using namespace std;

// Класс для представления узла бинарного дерева
class node {
public:
    char value;
    node* left;
    node* right;
    node* next = NULL;

    // Конструктор с параметром для узла
    node(char c) : value(c), left(NULL), right(NULL) {}

    // Конструктор по умолчанию для узла
    node() : left(NULL), right(NULL) {}

    // Объявление класса Stack и expression_tree в качестве дружественных классов
    friend class Stack;
    friend class expression_tree;
};

// Класс стека для хранения узлов дерева
class Stack {
    node* head = NULL;

public:
    // Функции push и pop для управления стеком
    void push(node*);
    node* pop();

    friend class expression_tree;
};

// Класс для реализации обхода дерева
class expression_tree {
public:
    // Функция для обхода по порядку
    void inorder(node* x) {
        if (x == NULL)
            return;
        else {
            inorder(x->left);
            cout << x->value << " ";
            inorder(x->right);
        }
    }
};

// Реализация функции push для стека
void Stack::push(node* x) {
    if (head == NULL) {
        head = x;
    } else {
        x->next = head;
        head = x;
    }
}

// Реализация функции pop для стека
node* Stack::pop() {
    node* p = head;
    head = head->next;
    return p;
}

// Основная программа
int main() {
    // Постфиксное выражение
    string s = "ABC*+D/";
    Stack e;
    expression_tree a;
    node *x, *y, *z;
    int l = s.length();

    // Построение дерева из постфиксного выражения
    for (int i = 0; i < l; i++) {
        if (s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/') {
            z = new node(s[i]);
            x = e.pop();
            y = e.pop();
            z->left = y;
            z->right = x;
            e.push(z);
        } else {
            z = new node(s[i]);
            e.push(z);
        }
    }

    // Вывод обхода дерева по порядку
    cout << "The Inorder Traversal of Expression Tree: ";
    a.inorder(z);

    return 0;
}
```

Вывод: Порядок обхода дерева выражений: A + B * C / D

### 3.1 Сбалансированные деревья
Максимальный эффект использования бинарного дерева поиска достигается, в том случае, если дерево сбалансировано:
- когда все узлы, кроме терминальных, имеют непустые и правый и левый соседние узлы; 
- все поддеревья, начинающиеся с одного и того же уровня, имеют одинаковую высоту.

Сбалансированное бинарное дерево – максимально широкое и низкое. Именно такими являются деревья, показанные на рисунках 2, 5, 9 и 10. Фактически все эти деревья, кроме 5, являются идеально сбалансированными.

Идеально сбалансированное дерево, у которого для каждой вершины: число вершин в левом и правом поддеревьях различается не более чем на 1

Менее строгое, но практически более удобное определение сбалансированности дерева – дерево сбалансированное, если для каждого узла исходящие ветви отличаются по высоте не более, чем на один уровень.

1. В идеально сбалансированном дереве количество элементов левого и правого поддеревьев различается не более, чем на 1
2. В сбалансированном высота левого и правого поддеревьев различается не более, чем на 1.

Обратный случай – вырожденное дерево, – выродившееся в линейный односвязный список. Такое дерево получается, если заносимые в него данные упорядочены по возрастанию (рисунок 11) или по убыванию.

Вырожденные деревья также получили название лево- или правоассоциативных или "лоз"

Если данные случайны, то получается дерево, в той или иной степени приближающееся к сбалансированному

Для бинарного идеально сбалансированного дерева с максимально возможным (для идеальной сбалансированности) числом узлов существуют простые соотношения между этим числом узлов N и высотой дерева (то есть, числом уровней) h:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/c08622ce-4b29-47f1-95e4-44c1ebc8d0c9)

Состояние сбалансированности (хотя бы в менее строгом смысле) часто оказывается настолько важным для тех областей, в которых деревья применяются, что для достижения этого состояния принимают специальные меры. 

Такими мерами являются
<br>
ЛИБО та или иная операция балансировки (принудительной) дерева, в том числе включающая в себя упомянутые операции поворотов
<br>
ЛИБО использование специальных видов деревьев, обеспечивающих балансировку при каждой операции добавления или удаления узла.

Основными видами таких деревьев являются:
- АВЛ-дерево
- красно-черное дерево

### 3.2 АВЛ-дерево
АВЛ-дерево получило свое название по фамилиям его разработчиков – советских математиков Георгия Максимовича Адельсон-Вельского (родился 8 января 1922 г. в Самаре) и Евгения Михайловича Ландиса, которые предложили использовать такое дерево в 1962 году.

АВЛ-дерево полностью удовлетворяет менее строгому определению сбалансированности дерева:

Дерево сбалансированное, если для каждого узла исходящие ветви отличаются по высоте не более, чем на один уровень.

Сбалансированность достигается за счет упомянутых выше операций поворотов (или вращений)
<br>
для сравнения высот ветвей в каждом узле двоичного дерева поиска используется ДОПОЛНИТЕЛЬНОЕ ПОЛЕ – признак сбалансированности ветвей (или разность их высот).

![image](https://github.com/mireashik/aood_3sem/assets/49165758/14976fc8-5c7f-4806-b7cc-feb67920d58c)

### 3.3 Красно-черное дерево
Красно-черное дерево (RB-tree) отличается от АВЛ-дерева смыслом признака сбалансированности:

вместо разности высот ветвей используется абстрактный «цвет» (красный или черный) и дерево строится по следующим правилам, рассматриваемым ниже. 

1. Все указатели на терминальные узлы считаются непустыми (то есть в дереве имеются фиктивные терминальные узлы). 
2. Все такие терминальные узлы считаются «черными». 
3. Все узлы, соседние с «красными» узлами, считаются «черными» (то есть запрещена ситуация с двумя «красными» узлами подряд). 
4. В левой и правой ветвях дерева, ведущих от его корня к листьям, число «чёрных» узлов одинаково. Это число называется «черной высотой» дерева. 

![image](https://github.com/mireashik/aood_3sem/assets/49165758/0d078755-1909-485f-b3c6-0f46c3ae069a)

Теоретически считается, что красно-чёрное дерево требует меньшего объёма памяти для хранения отдельного узла, чем АВЛ-дерево, представления цвета достаточно всего одного бита
<br>
не всегда пригоден на практике, так как решаемая задача может не допускать такого разделения узлов.

Красно-чёрное дерево – один из видов самобалансирующихся двоичных деревьев поиска, гарантирующих логарифмический рост высоты дерева от числа узлов и позволяющее быстро выполнять основные операции дерева поиска: добавление, удаление и поиск узла

Красно-чёрное дерево используется для организации сравнимых данных, таких как фрагменты текста или числа. Листовые узлы красно-чёрных деревьев не содержат данных

### 3.4. Вращения (повороты), используемы при балансировке
Переприсвоения значений указателей в узлах дерева и, как следствие, перепроведение связей между узлами, после которого высоты левой и правой ветвей оказываются одинаковыми (или отличаются не более чем на один уровень) и дерево считается сбалансированным

![image](https://github.com/mireashik/aood_3sem/assets/49165758/78dd86f9-671b-40f6-9208-04ce5717a54d)

После вращения в рассматриваемом случае высоты левой и правой ветвей нового корня будут одинаковыми.

Операция вращения может применяться не только для балансировки АВЛили красно-чёрных деревьев, но и обычных двоичных деревьев, не обязательно деревьев поиска.

Например преобразование исходного дерева в левоассоциативное (то есть в левую «лозу»)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/6e825de3-2b19-44c1-9014-44a95f291b60)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/033ae547-0d85-43ca-9c40-fe24721152fc)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/b3ed8a07-7b06-4cf1-a096-03d2939dcf47)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/0c9a79b8-4aa5-4efd-8d77-084b7ebb90fe)

Относительно АВЛ-дерева балансировкой вершины называется операция, которая в случае разницы высот левого и правого поддеревьев равна 2, изменяет связи предок-потомок в поддереве данной вершины так, что разница становится ≤ 1, иначе ничего не меняет.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/326296f1-3cf3-45f6-8305-d5933212aab3)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/1757bab6-eb93-407b-8c33-7ffc99d32ded)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/c1117bba-83d9-4735-a650-83612c6c81b6)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/1dcf3462-8780-4028-b374-541ab6eb1279)

полная высота уменьшается не более чем на 1 и не может увеличиться
<br>
большое вращение это комбинация правого и левого малого вращения

### 3.5. АВЛ-деревья и С++
#### 3.5.1 Понятие АВЛ-дерева
![image](https://github.com/mireashik/aood_3sem/assets/49165758/66492c4e-dbf6-4aec-986f-04cb217d35af)

Для поиска нужного ключа в АВЛ-дереве можно использовать стандартный алгоритм

Особенностью АВЛ-дерева является то, что оно является сбалансированным в следующем смысле: для любого узла дерева высота его правого поддерева отличается от высоты левого поддерева не более чем на единицу

высота дерева логарифмически зависела от числа его узлов: 

высота h АВЛ-дерева с n ключами лежит в диапазоне от log2(n+1) до 1.44 log2(n + 2) − 0.328


#### 3.5.2 Структура узлов АВЛ-дерева
```c++
struct node // структура для представления узлов дерева
{
int key;
unsigned char height; // height − высоту поддерева с корнем в данном узле
node* left; // указатели на левое и правое поддеревья
node* right;
node(int k) { key = k; left = right = 0; height = 1; }
};
```

Узлы АВЛ-дерева хранят не высоту, а разницу высот правого и левого поддеревьев (так называемый balance factor), которая может принимать только три значения -1, 0 и 1

Таким образом, хранение высот с одной стороны не увеличивает объем памяти, отводимой под узлы дерева, а с другой стороны существенно упрощает реализацию некоторых операций

```c++
unsigned char height(node* p) {
return p?p->height:0;
}
```

```c++
int bfactor(node* p) {
return height(p->right)-height(p->left);
}
```

```c++
void fixheight(node* p) {
unsigned char hl = height(p->left);
unsigned char hr = height(p->right);
p->height = (hl>hr?hl:hr)+1;
}
```


#### 3.5.3 Балансировка узлов
В процессе добавления или удаления узлов в АВЛ-дереве возможно возникновение ситуации, когда balance factor некоторых узлов оказывается равными 2 или -2, т.е. возникает разбалансировка поддерева

Простой поворот вправо (влево):

![image](https://github.com/mireashik/aood_3sem/assets/49165758/9835a8f0-7b8e-47b1-bf58-2ecf98621a82)

Код, реализующий правый поворот

```c++
node* rotateright(node* p) // правый поворот вокруг p
{
node* q = p->left;
p->left = q->right;
q->right = p;
fixheight(p);
fixheight(q);
return q;
}
```

Левый поворот является симметричной копией правого

```c++
node* rotateleft(node* q) // левый поворот вокруг q
{
node* p = q->right;
q->right = p->left;
p->left = q;
fixheight(q);
fixheight(p);
return p;
}
```

Высота правого поддерева узла p на 2 больше высоты левого поддерева

![image](https://github.com/mireashik/aood_3sem/assets/49165758/bb69dc38-26d4-4466-b2eb-1dc52cb71bb4)

для исправления разбалансировки в узле p достаточно выполнить
<br>
ЛИБО простой поворот ВЛЕВО вокруг p (рисунок 24)
<br>
ЛИБО так называемый большой поворот ВЛЕВО вокруг того же p (рисунок 25)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/2f78f073-cf4e-4e32-9ab9-dd56fc591084)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/37c309fa-b406-4aa3-b56e-5089452a9f7b)

```c++
node* balance(node* p) // балансировка узла p
{
fixheight(p);
if( bfactor(p)==2 )
{
if( bfactor(p->right) < 0 )
p->right = rotateright(p->right);
return rotateleft(p);
}
if( bfactor(p)==-2 )
{
if( bfactor(p->left) > 0 )
p->left = rotateleft(p->left);
return rotateright(p);
}
return p; // балансировка не нужна
}
```

Описанные функции поворотов и балансировки также не содержат ни циклов, ни рекурсии, а значит, выполняются за постоянное время, не зависящее от размера АВЛ-дерева

#### 3.5.4 Вставка ключей
Спускаемся вниз по дереву, выбирая правое или левое направление движения в зависимости от результата сравнения ключа в текущем узле и вставляемого ключа.

Единственное отличие заключается в том, что при возвращении из рекурсии (т.е. после того, как ключ вставлен либо в правое, либо в левое поддерево, и это дерево сбалансировано) выполняется балансировка текущего узла. 

```c++
node* insert(node* p, int k) { // вставка ключа k в дерево с корнем p
    if(!p)
        return new node(k);
    if(k< p-> key)
        p-> left = insert(p -> left, k);
    else
        p -> right = insert(p -> right, k);
    return balance(p);
}
```

#### 3.6.5 Удаление ключей
Находим узел p с заданным ключом k (если не находим, то делать ничего не надо), в правом поддереве находим узел min с наименьшим ключом и заменяем удаляемый узел p на  найденный узел min.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/54ebbe39-d21e-4047-893a-04eb56bfad4b)

```c++
node* findmin(node* p) { // поиск узла с минимальным ключом в дереве p 
    return p->left?findmin(p->left):p;
}
```

```c++
node* removemin(node* p) { // удаление узла с минимальным ключом из дерева p.
    if( p->left==0 )
        return p->right;
    p->left = removemin(p->left);
    return balance(p);
}

```c++
node* remove(node* p, int k) { // удаление ключа k из дерева
    if( !p )
        return 0;
    if( k < p->key )
        p->left = remove(p->left,k);
    else if( k > p->key )
        p->right = remove(p->right,k);
    else { // k == p->key 
        node* q = p->left;
        node* r = p->right;
        delete p;
        if( !r )
            return q;
        node* min = findmin(r);
        min->right = removemin(r);
        min->left = q;
        return balance(min);
    }
    return balance(p); // При выходе из рекурсии выполняем балансировку:
}
```

Таким образом, время выполнения всех трех базовых операций гарантированно логарифмически зависит от числа узлов дерева

```c++
struct node // Структура для представления узлов дерева
{
    int key;               // Ключ узла
    unsigned char height;  // Высота узла в дереве
    node* left;            // Левое поддерево
    node* right;           // Правое поддерево

    // Конструктор узла
    node(int k) { key = k; left = right = 0; height = 1; }
};

// Функция для получения высоты узла
unsigned char height(node* p)
{
    return p ? p->height : 0;
}

// Функция для вычисления баланса узла
int bfactor(node* p)
{
    return height(p->right) - height(p->left);
}

// Функция для коррекции высоты узла
void fixheight(node* p)
{
    unsigned char hl = height(p->left);
    unsigned char hr = height(p->right);
    p->height = (hl > hr ? hl : hr) + 1;
}

// Функция для правого поворота вокруг узла p
node* rotateright(node* p)
{
    node* q = p->left;
    p->left = q->right;
    q->right = p;
    fixheight(p);
    fixheight(q);
    return q;
}

// Функция для левого поворота вокруг узла q
node* rotateleft(node* q)
{
    node* p = q->right;
    q->right = p->left;
    p->left = q;
    fixheight(q);
    fixheight(p);
    return p;
}

// Функция для балансировки узла p
node* balance(node* p)
{
    fixheight(p);

    if (bfactor(p) == 2)
    {
        if (bfactor(p->right) < 0)
            p->right = rotateright(p->right);
        return rotateleft(p);
    }

    if (bfactor(p) == -2)
    {
        if (bfactor(p->left) > 0)
            p->left = rotateleft(p->left);
        return rotateright(p);
    }

    return p; // Балансировка не нужна
}

// Функция для вставки ключа k в дерево с корнем p
node* insert(node* p, int k)
{
    if (!p) return new node(k);
    if (k < p->key)
        p->left = insert(p->left, k);
    else
        p->right = insert(p->right, k);
    return balance(p);
}

// Функция для поиска узла с минимальным ключом в дереве p
node* findmin(node* p)
{
    return p->left ? findmin(p->left) : p;
}

// Функция для удаления узла с минимальным ключом из дерева p
node* removemin(node* p)
{
    if (p->left == 0)
        return p->right;
    p->left = removemin(p->left);
    return balance(p);
}

// Функция для удаления ключа k из дерева p
node* remove(node* p, int k)
{
    if (!p) return 0;
    if (k < p->key)
        p->left = remove(p->left, k);
    else if (k > p->key)
        p->right = remove(p->right, k);
    else // k == p->key
    {
        node* q = p->left;
        node* r = p->right;
        delete p;
        if (!r) return q;
        node* min = findmin(r);
        min->right = removemin(r);
        min->left = q;
        return balance(min);
    }
    return balance(p);
}
```

### 3.6 В-деревья
В-деревья (Байера-МакКрейта) являются сбалансированными деревьями, у которых число ветвей, исходящих из узлов, может быть два и более

![image](https://github.com/mireashik/aood_3sem/assets/49165758/c5314d8a-e6dc-4160-a96f-57146562ae6f)

В зависимости от области применения таких деревьев, полезные данные могут храниться только в их ТЕРМИНАЛЬНЫХ узлах 

Модификацией В-дерева является В+дерево
<br>
В++ дерево – это В-дерево, у которого связный список формируется не только на самом нижнем уровне, но и на уровень выше

В тех случаях, когда максимальное число ветвей, исходящих из узла, ограничено, получаются, например, 2-3-деревья и 2-3-4- деревья

![image](https://github.com/mireashik/aood_3sem/assets/49165758/900546ae-b602-4645-bdbc-ed5928a834df)

Кроме рассмотренных сбалансированных деревьев существует также расширяемое дерево Тарьяна (splay-tree), являющее двоичным деревом поиска и обеспечивающее балансировку без каких-либо дополнительных признаков.

При необходимости обычное двоичное дерево поиска можно принудительно балансировать, например, алгоритмом, аналогичным нисходящему обходу дерева. Но при этом не только не гарантируется эффективность алгоритма, но и существует возможность получить алгоритм с худшим временем работы

### 3.7 Подробнее о В-деревьях или B-tree
- поиск элемента;
- поиск минимального (максимального) элемента;
- вставка;
- удаление;
- переход к родителю;
- переход к ребенку. 

Основные операции в деревьях выполняются за время пропорциональное его высоте. Сбалансированные деревья минимизируют свою высоту (к примеру, высота бинарного сбалансированного дерева с n узлами равна log2n)

В чем же проблема этих стандартных деревьев поиска? Мы не можем хранить всё это дерево в оперативной памяти. Такие деревья как красно-черное или Декартово дерево (рассмотрим ниже) будут требовать от нас log n обращений к стороннему носителю. При больших n это очень много. Как раз эту проблему и призваны решить В-деревья.

Они созданы специально для эффективной работы с дисковой памятью (сторонним носителем), а точнее – они минимизируют обращения типа ввода-вывода

#### 3.7.2 Структура
При построении B-дерева применяется фактор t, который называется минимальной степенью. Каждый узел, кроме корневого, должен иметь, как минимум t–1, и не более 2t–1 ключей. Обозначается n[x] – количество ключей в узле  x.

Если x не является листом, то он имеет n[x]+1 детей. Если занумеровать ключи в узле x, как k[i], а детей c[i], то для любого ключа в поддереве с корнем c[i] (пусть k1), выполняется следующее  неравенство – k[i-1] ≤k1≤k[i] (для c[0]: k[i-1] = -∞, а для c[n[x]]: k[i] = +∞)

Все листья B-дерева должны быть расположены на одной высоте, которая и является высотой дерева. Высота B-дерева с n≥1 узлами и минимальной степенью t≥2 не превышает logt(n+1)

h ≤ logt((n+1)/2) – логарифм по основанию t

#### 3.7.3 Операции, выполнимые с B-деревом
**Поиск**

Поиск в B-дереве очень схож с поиском в бинарном дереве, только здесь необходимо сделать выбор пути к потомку не из 2 вариантов, а из нескольких

![image](https://github.com/mireashik/aood_3sem/assets/49165758/9f7abb35-5798-46b8-b22b-593fccec5c0e)

**Добавление**

Операция добавления существенно сложнее, чем в бинарном дереве, так как просто создать новый лист и вставить туда ключ нельзя

Если лист был заполнен, то в нем находилось 2t-1 ключей. Следовательно, разбиваем на 2 по t-1, а средний элемент (для которого t-1 первых ключей меньше его, а t-1 последних больше) перемещается в родительский узел

Соответственно, если родительский узел также был заполнен – то нам опять приходится разбивать. И так далее до корня (если разбивается корень – то появляется новый корень и глубина дерева увеличивается).

На рисунке 30 проиллюстрировано то же дерево, что и в поиске (t=3). Только теперь добавляем ключ «15». В поисках позиции для нового ключа мы натыкаемся  на заполненный узел (7, 9, 11, 13, 16). Следуя алгоритму, разбиваем его – при этом  «11» переходит в родительский узел, а исходный разбивается на 2. Далее ключ «15»  вставляется во второй «отколовшийся» узел. 

![image](https://github.com/mireashik/aood_3sem/assets/49165758/37ae3fc9-7685-4d2c-8c4a-004fa401e64a)

**Удаление**
Удаление ключа из B-дерева еще более громоздкий и сложный процесс, чем вставка. Это связано с тем, что удаление из внутреннего узла требует перестройки дерева в целом. 

Только в данном случае нужно отслеживать, когда ключей t-1 (то есть, если из этого узла удалить ключ – то узел не сможет существовать)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/82289824-edbb-49b4-b0d0-b6dc2e8e1c52)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/708137ab-1761-42af-894e-9b5267bbd294)

Итак, мы убедились в том, что B-дерево является быстрой структурой данных (наряду с такими, как красно-черное, АВЛ). И еще одно важное свойство, которое мы получили, рассмотрев стандартные операции, – автоматическое поддержание свойства сбалансированности – заметим, что мы нигде не балансируем его специально

**Базы данных**

B-дерево несомненно является более выгодной структурой данных для случаев, когда мы имеем большой объем информации.

Очевидно, увеличивая t (минимальную степень), мы увеличиваем ветвление нашего дерева, а следовательно уменьшаем высоту! Какое же t выбрать? – Выбираем согласно размеру оперативной памяти, доступной нам (т.е. сколько ключей мы можем единовременно просматривать). Обычно это число находится в пределах от 50 до 2000. Пусть у нас есть миллиард ключей, и t=1001. Тогда нам потребуется всего лишь 3 дисковые операции для поиска любого ключа! При этом учитываем, что корень мы можем хранить постоянно (что мало)

Также, мы читаем не отдельные данные с разных мест, а целыми блоками. 

### 3.8.1 Дерево Фибоначчи
Дерево Фибоначчи − это сбалансированное АВЛ-дерево с минимально возможным количеством узлов (вершин) при заданной высоте: каждый узел дерева имеет левое поддерево высотой на единицу больше, чем его правое поддерево.

1. Если для какой-либо из вершин высота поддерева, для которого эта вершина является корнем, равна h, то правое и левое поддерево этой вершины имеют высоты равные соответственно h−1 и h−2 , или h−2 и h−1. Каждое поддерево дерева Фибоначчи также является деревом Фибоначчи.
2. Пустое дерево ‒ дерево Фибоначчи высоты 0.
3. Дерево с одной вершиной ‒ дерево Фибоначчи высоты 1.

его левое поддерево помещается дерево Фибоначчи высотой h-1
<br>
правое поддерево ‒ дерево Фибоначчи высотой h-2

![image](https://github.com/mireashik/aood_3sem/assets/49165758/d0433413-1dfb-4f2f-abaa-187f795b2588)

Для произвольного значения h число вершин можно описать рекуррентно: `Nh = Nh-1 + Nh-2 + 1`

### 3.8.2 Фибоначчиева куча
Приоритетная очередь

1. Добавление нового элемента O(1)
2. Определение минимального элемента O(1)
3. Слияние двух фибоначчиевых куч O(1)
4. Удаление минимального элемента O(logN)
5. Изменение приоритета элемента O(logN)

Фибоначчиева куча представляет собой набор фибоначчиевых деревьев.
<br>
Фибоначчиево дерево - сын не должен превышать своего отца. Братья-узлы объединены в кольцевой список.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/ae1b420e-72ca-483d-a190-ae113d0cc09a)

```c++
typedef bool (*cmpPtr)(node*, node*);
struct node {
    node* parent; // указатель на отца
    node* child; // указатель на одного из сыновей
    node* left; // указатель на левого брата
    node* right; // указатель на правого брата
    int degree; // количество дочерних узлов
    bool mark; // метка - был ли удален один из дочерних элементов
    int key; // числовое значение узла
};
struct fib_heap {
    node* min; // узел с минимальным корнем
    int roots_amount; // количество узлов
    cmpPtr less; // указатель на функцию-компаратор
}
```

**Последовательное добавление элементов массива {5,1,3,2,4,0,7,6}**

![image](https://github.com/mireashik/aood_3sem/assets/49165758/be00a4bf-e986-4390-ac6c-4ff5949afc03)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/a8fc56af-48af-41fc-91dd-1d631dbf5074)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/8640c219-9ff7-4343-a297-38fde2a653cf)

```c++
void add(node* Node, node** bro, node* par = NULL) {
    if (*bro == NULL) {
        *bro = Node;
        Node->left = Node;
        Node->right = Node;
    }
    else {
        Node->right = (*bro)->right;
        Node->right->left = Node;
        Node->left = *bro;
        (*bro)->right = Node;
    }
    if (less(Node, *bro))
    *bro = Node;
    
    if(*bro == min) {
        roots_amount++;
        Node->parent = NULL;
    }
    if (par){
        par->degree++;
        Node->parent = par;
    }
}

node* add(int key) {
    node* Node = new node(key);
    add(Node,&min);
    return Node;
}
```

**Определение минимального элемента**

Указатель на минимальный элемент кучи хранится в специальном поле. Доступ к нему осуществляется за O(1).

**Объединение 2 фибоначиевых куч**

Функция работает за константное время. Так как корневые узлы объединены в циклический список, то для объединения 2 куч необходимо объединить 2 циклических списка корней в один.

```c++
struct fib_heap {
    void union_fib_heap(fib_heap &fb) {
        union_root(fb.min,fb.roots_amount);
        if (!min || (fb.min && less(fb.min, min)))
        min = fb.min;
        fb.clear();
    }
    void union_root(node* Node, int nodes_amount) {
        if (Node == NULL)
            return;
        if (min == NULL) {
            min = Node;
            roots_amount = nodes_amount;
        }
        else {
            node *L = Node->left;
            node *R = min->right;
            min->right = Node;
            Node->left = min;
            L->right = R;
            R->left = L;
            roots_amount += nodes_amount;
        }
    }
};

int main() {
    fib_heap fh1,fh2;
fh1.union_fib_heap(fh2);
}
```

**Удаление элемента**

Минимальный элемент имеет детей - делаем их корневыми узлами. Удаляем минимальный элемент из кольцевого списка корней, перебрасываем ссылки с левого на правого брата.
<br>
Новый минимальный элемент кучи становится правым братом удаляемого элемента.

Если удаляемый элемент является последним - обрабатываем его отдельно
<br>
Удаляемый элемент не является последним - делаем процесс уплотнения кучи (consolidate)

```c++
int extract_min() {
    node* res = min;
    if (res) {
        childs_in_root(res);
        remove_root(res);
        if (res->right == res)
        min = 0;
        else {
        min = min->right;
        consolidate();
        }
    }
    int ans = res ? res -> key: ERROR;
    delete res;
    return ans;
}
```

**Процесс уплотнения кучи**

![image](https://github.com/mireashik/aood_3sem/assets/49165758/8e5839e9-ac81-4a80-8100-4b8222f231f7)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/d287de4f-7406-49c9-ae83-c758c5f63481)

**Изменение приоритета элемента**

Новый приоритет элемента не ниже чем приоритет отца - ничего делать не нужно.

Удаляем текущий элемент А, если отец Р(А) ссылался на него, то ссылку в Р перебрасываем на правого брата А.
<br>
Уменьшаем счетчик количества сыновей у P, mark = true
<br>
эта метка значит что у элемента P был удален сын, а также у 1 узла будет удалено более 1 сына, то его нужно поместить в кольцевой список корней.
<br>
Добавляем элемент A в кольцевой список корней. Если приоритет элемента A < минимального корня, то A - новый минимальный элемент кучи.

Если у отца элемента A – элемента P ранее удалялся сын, то необходимо выполнить поместить элемент P в кольцевой список корней.

#### Дерево Фенвика
Структура данных, требующая O(n) памяти и позволяющая эффективно (за O(logn)) выполнять следующие операции:

- изменять значение любого элемента в массиве
- выполнять некоторую ассоциативную, коммутативную, обратимую операцию на отрезке [i,j]

Дерево Фенвика занимает в константное значение раз меньше памяти, чем дерево отрезков
<br>
дерево Фенвика хранит только значение операции для каких-то элементов
<br>
дерево отрезков хранит сами элементы и частичные результаты операции на подотрезках (*поэтому оно занимает как минимум в 2 раза больше памяти*)

