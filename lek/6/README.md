## Дерево поиска
С числом ветвей > 2 – часто такие деревья называют мультивариантными (многопутевыми, сильноветвящимися) или K-деревьями (K-мерными). B-деревья (различные деревья Байера-МакКрейта с вариантами, например, 2-3-деревья, 2-3-4-деревья) и тому подобное.

- сбалансированное дерево (уровень в левом и правом поддереве различаются либо на 0, либо на 1)
- идеально сбалансированное (число вершин в левом и правом поддеревьях различается не более чем на 1)
- вырожденное (каждый уровень - 1 вершина)
- остов дерево графа (дерево, подграф данного графа, с тем же числом вершин, что и у исходного графа)

Автоматическая балансировка дерева выполняется, например, для АВЛ-деревьев, красно-черных деревьев

### 1.2 Двоичные деревья поиска
**Пирамида** («куча, сортирующее дерево поиска») – значения всех узлов, размещённых на 1 уровне, больше (или меньше) значений узлов, размещенных на вышележащем уровне

![image](https://github.com/mireashik/aood_3sem/assets/49165758/e2eb069d-747d-4971-944e-8cf977f4a51f)

Обладает 3 условиями:
1. Значение в любой вершине не меньше, чем значения её потомков.
2. Глубина всех листьев (расстояние до корня) отличается не более чем на 1 слой.
3. Последний слой заполняется слева направо без «дырок».

Двоичное дерево поиска - значения всех узлов, правее некоторого узла, больше значений узлов, размещенных левее

![image](https://github.com/mireashik/aood_3sem/assets/49165758/4276579a-c5d9-43f4-b7d1-ca8ba106d2ef)

В дальнейшем под двоичными деревьями будут подразумеваться именно двоичные деревья поиска.

Структура пирамиды и дерева практически одинакова, отличаются только характером размещения данных.

В чём отличие бинарных деревьев от двусвязного списка? Бывают случаи, когда они ничем не отличаются. Более того, могут не отличаться не только от двусвязного списка, но и от односвязного списка
<br>
основное отличие – у списка соседними являются предшествующий и последующий элементы, и структура линейна
<br>
У бинарного дерева поиска же соседними являются элементы с меньшим и большим ключом, и структура ветвящаяся – в виде  дерева

![image](https://github.com/mireashik/aood_3sem/assets/49165758/c7fa72c2-2354-4d5e-b021-ad463c23ab1a)

Однако память - линейна, узел дерева хранится в памяти так:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/9a83ba7c-f230-499c-b4ea-9c0d72d2a50c)

Двоичное дерево в памяти:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/e37dad87-1755-4b52-a488-d5dce642740f)

Ещё раз вспомним о листе, высоте дерева

Области применения деревьев: 
- для хранения информации, как таковой
- в процедурах поиска и сортировки
- для описания хранения файлов на дисковых носителях
- при построении эффективных кодов для сжатия информации (коды Шеннона–Фано и Хаффмена). 

Если дерево отсортировано (а это дерево именно такое), то операция поиска выполняется быстро, с эффективностью, близкой к эффективности двоичного поиска.

#### Выводы
Бинарное дерево – иерархическая структура данных, в которой каждый узел имеет значение (иногда оно является и ключом), а также ссылки на левого и правого потомка.
<br>
Узел на самом верхнем уровне - корень. Узлы, не имеющие потомков - лист.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/f72d1943-e0f6-4a99-af06-742d4b4d61fa)

Дополнительные свойства бинарного дерева поиска:
- значение левого потомка меньше значения родителя
- значение правого потомка больше значения родителя для каждого узла дерева

То есть, данные в бинарном дереве поиска хранятся в отсортированном виде. Поиск также идёт по правилам и строгому порядку, отсортированный вид при удалении узла не нарушается.

### 1.3 Операции с двоичными деревьями поиска

#### 1.3.1 Добавление узла в дерево

#### 1.3.2 Прохождение дерева

#### 1.3.3 Поиск узла в дереве

#### 1.3.4 Удаление узла из дерева

#### 1.3.5 Удаление всех узлов дерева

#### 1.3.6 Подсчёт узлов

#### 1.3.7 Определение высоты дерева

### 2. Дерево выражений

### 3.1 Сбалансированные деревья

### 3.2 АВЛ-дерево

### 3.3 Красно-черное дерево

### 3.4. Вращения (повороты), используемы при балансировке

### 3.5. АВЛ-деревья и С++

#### 3.5.1 Понятие АВЛ-дерева

#### 3.5.2 Структура узлов АВЛ-дерева

#### 3.5.3 Балансировка узлов

#### 3.5.4 Вставка ключей

#### 3.6.5 Удаление ключей

### 3.6 В-деревья

### 3.7 Подробнее о В-деревьях или B-tree

#### 3.7.2 Структура

#### 3.7.3 Операции, выполнимые с B-деревом

**Добавление**

**Удаление**

**Базы данных**

### 3.8.1 Дерево Фибоначчи

### 3.8.2 Фибоначчиева куча
