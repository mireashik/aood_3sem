## Дерево поиска
С числом ветвей > 2 – часто такие деревья называют мультивариантными (многопутевыми, сильноветвящимися) или K-деревьями (K-мерными). B-деревья (различные деревья Байера-МакКрейта с вариантами, например, 2-3-деревья, 2-3-4-деревья) и тому подобное.

- сбалансированное дерево (уровень в левом и правом поддереве различаются либо на 0, либо на 1)
- идеально сбалансированное (число вершин в левом и правом поддеревьях различается не более чем на 1)
- вырожденное (каждый уровень - 1 вершина)
- остов дерево графа (дерево, подграф данного графа, с тем же числом вершин, что и у исходного графа)

Автоматическая балансировка дерева выполняется, например, для АВЛ-деревьев, красно-черных деревьев

### 1.2 Двоичные деревья поиска
**Пирамида** («куча, сортирующее дерево поиска») – значения всех узлов, размещённых на 1 уровне, больше (или меньше) значений узлов, размещенных на вышележащем уровне

![image](https://github.com/mireashik/aood_3sem/assets/49165758/e2eb069d-747d-4971-944e-8cf977f4a51f)

Обладает 3 условиями:
1. Значение в любой вершине не меньше, чем значения её потомков.
2. Глубина всех листьев (расстояние до корня) отличается не более чем на 1 слой.
3. Последний слой заполняется слева направо без «дырок».

Двоичное дерево поиска - значения всех узлов, правее некоторого узла, больше значений узлов, размещенных левее

![image](https://github.com/mireashik/aood_3sem/assets/49165758/4276579a-c5d9-43f4-b7d1-ca8ba106d2ef)

В дальнейшем под двоичными деревьями будут подразумеваться именно двоичные деревья поиска.

Структура пирамиды и дерева практически одинакова, отличаются только характером размещения данных.

В чём отличие бинарных деревьев от двусвязного списка? Бывают случаи, когда они ничем не отличаются. Более того, могут не отличаться не только от двусвязного списка, но и от односвязного списка
<br>
основное отличие – у списка соседними являются предшествующий и последующий элементы, и структура линейна
<br>
У бинарного дерева поиска же соседними являются элементы с меньшим и большим ключом, и структура ветвящаяся – в виде  дерева

![image](https://github.com/mireashik/aood_3sem/assets/49165758/c7fa72c2-2354-4d5e-b021-ad463c23ab1a)

Однако память - линейна, узел дерева хранится в памяти так:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/9a83ba7c-f230-499c-b4ea-9c0d72d2a50c)

Двоичное дерево в памяти:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/e37dad87-1755-4b52-a488-d5dce642740f)

Ещё раз вспомним о листе, высоте дерева

Области применения деревьев: 
- для хранения информации, как таковой
- в процедурах поиска и сортировки
- для описания хранения файлов на дисковых носителях
- при построении эффективных кодов для сжатия информации (коды Шеннона–Фано и Хаффмена). 

Если дерево отсортировано (а это дерево именно такое), то операция поиска выполняется быстро, с эффективностью, близкой к эффективности двоичного поиска.

#### Выводы
Бинарное дерево – иерархическая структура данных, в которой каждый узел имеет значение (иногда оно является и ключом), а также ссылки на левого и правого потомка.
<br>
Узел на самом верхнем уровне - корень. Узлы, не имеющие потомков - лист.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/f72d1943-e0f6-4a99-af06-742d4b4d61fa)

Дополнительные свойства бинарного дерева поиска:
- значение левого потомка меньше значения родителя
- значение правого потомка больше значения родителя для каждого узла дерева

То есть, данные в бинарном дереве поиска хранятся в отсортированном виде. Поиск также идёт по правилам и строгому порядку, отсортированный вид при удалении узла не нарушается.

### 1.3 Операции с двоичными деревьями поиска
- добавление элемента
- удаление
- прохождение (просмотр)
- поиск элементов
- принудительной балансировки
- подсчета числа узлов в дереве
- измерения высоты дерева
- поиска ближайшего общего корня

При балансировке деревьев используются операции поворотов (вращений), простых и двойных, левых и правых.

#### 1.3.1 Добавление узла в дерево
Последовательно строим

![image](https://github.com/mireashik/aood_3sem/assets/49165758/671813c4-e99f-421a-b8da-df1184209c7f)

При поступлении записи с ключом k, ключ сравнивают, начиная с корня, с ключом очередного узла. В зависимости от результата сравнения, процесс продолжают в левой или правой ветви пока не будет достигнут один из узлов, с которым можно связать входящую запись.

```c++
// Функция для добавления узла в бинарное дерево поиска
// Принимает указатели на корень дерева (tree), текущий узел (r), предыдущий узел (prev) и данные для нового узла (buf)
void add_node(node*& tree, node*& r, node*& prev, node& buf) 
{
    // Если текущий узел r равен NULL, создаем новый узел
    if (r == NULL) 
    { 
        r = new node; // Выделяем память под новый узел
        r->left = NULL; // Инициализируем указатель на левое поддерево как NULL
        r->right = NULL; // Инициализируем указатель на правое поддерево как NULL
        r->key = buf.key; // Копируем ключ из данных buf в текущий узел
        r->data = buf.data; // Копируем данные из buf в текущий узел

        // Если дерево не пусто и предыдущий узел не равен текущему узлу r,
        // то определяем, является ли r левым или правым потомком предыдущего узла prev
        if (tree != r) 
            if (buf.key < prev->key) 
                prev->left = r; // Если ключ меньше, чем ключ предыдущего узла, устанавливаем r как левого потомка
            else 
                prev->right = r; // Иначе устанавливаем r как правого потомка

        return; // Возвращаемся из функции после добавления нового узла
    } 

    // Если ключ данных для нового узла меньше ключа текущего узла,
    // рекурсивно вызываем add_node для левого поддерева
    if (buf.key < r->key) 
        add_node(tree, r->left, r, buf); 
    else 
        // Иначе рекурсивно вызываем add_node для правого поддерева
        add_node(tree, r->right, r, buf); 
}
```

#### 1.3.2 Прохождение дерева
может выполняться с разными целями: 
- просмотр (вывод на дисплей)
- сохранение в файл
- поиск

Прохождение дерева может выполняться по методам:
- «в глубину»
- «в ширину»

Существует три способа прохождения дерева в ГЛУБИНУ:
1. Последовательный (он же инфиксный, симметричный, поперечный) – дерево проходится, начиная с левой ветви вверх к корню, затем к правой ветви.
2. Нисходящий (префиксный или прямой) – от корня к левой ветви, затем к правой.
3. Восходящий (постфиксный или обратный) – проходится левая ветвь, затем правая, затем корень.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/4f335f3d-ed38-4b6f-9ace-37d949f57bef)

Последовательный способ удобен для сортировки данных.
<br>
Нисходящий способ удобен для сохранения дерева 
<br>
Восходящий обход может использоваться при полном удалении всего дерева

```c++
// Функция для обхода дерева поиска в порядке "Inorder"
// Принимает указатель на текущий узел (r)
void inorder(node* r) 
{
    // Если текущий узел r равен NULL, завершаем рекурсию
    if (r == NULL)
        return;

    // Рекурсивный вызов для левого поддерева
    inorder(r->left);

    // Выводим ключ текущего узла
    cout << r->key << " ";

    // Рекурсивный вызов для правого поддерева
    inorder(r->right);
}

// Функция для обхода дерева поиска в порядке "Preorder"
// Принимает указатель на текущий узел (r)
void preorder(node* r)
{
    // Если текущий узел r равен NULL, завершаем рекурсию
    if (r == NULL)
        return;

    // Выводим ключ текущего узла
    cout << r->key << " ";

    // Рекурсивный вызов для левого поддерева
    preorder(r->left);

    // Рекурсивный вызов для правого поддерева
    preorder(r->right);
}

// Функция для обхода дерева поиска в порядке "Postorder"
// Принимает указатель на текущий узел (r)
void postorder(node* r) 
{
    // Если текущий узел r равен NULL, завершаем рекурсию
    if (!r)
        return;

    // Рекурсивный вызов для левого поддерева
    postorder(r->left);

    // Рекурсивный вызов для правого поддерева
    postorder(r->right);

    // Выводим ключ текущего узла
    cout << r->key << " ";
}
```

Обход бинарного дерева поиска в ШИРИНУ выполняется с помощью вспомогательной структуры данных – очереди или стека. 

![image](https://github.com/mireashik/aood_3sem/assets/49165758/cd622f4d-58cb-44cd-8e80-2b8ebbe58bcd)

Результат обхода дерева, показанного на рисунке 9 с выводом содержимого узлов на экран, следующий: d b f a c e g

```c++
// Структура для представления списка узлов
struct Link2
{
    node* n;         // Узел дерева
    Link2* next, *prev;  // Указатели на следующий и предыдущий узлы в списке
};

// Функция вставки узла в список
// Принимает указатель на предыдущий узел (Pred) и данные для нового узла (data)
void Insert2(Link2* Pred, node* data)
{
    // ...

    Loc->n = data; // Ввод узла дерева в список

    // ...

    // Обычные операции вставки в список

    // ...
}

// Функция извлечения узла из очереди
// Принимает указатель на узел в списке (Del)
// Возвращает указатель на извлеченный узел дерева
node* Retrieve2(Link2* Del)
{
    node* a = Del->n;
    Delete2(Del); // Предполагается, что функция Delete2 удаляет узел из списка

    return a;
}

// Функция обхода дерева в ширину
// Принимает указатель на корень дерева (r)
void WidthTraverse(node* r)
{
    if (!r)
        return;

    // Создание локальной очереди
    Link2* L2 = new Link2;

    // Инициализация указателей очереди на саму себя (пустая очередь)
    L2->next = L2;
    L2->prev = L2;

    // Занесение корневого узла в очередь
    Insert2(L2->prev, r);

    // Пока очередь не пуста
    while (L2->prev != L2)
    {
        // Извлечение узла из очереди
        node* cur = Retrieve2(L2->next);

        // Вывод ключа текущего узла
        printf("%d ", cur->key);

        // Если есть левый потомок, добавляем его в очередь
        if (cur->left)
            Insert2(L2->prev, cur->left);

        // Если есть правый потомок, добавляем его в очередь
        if (cur->right)
            Insert2(L2->prev, cur->right);
    }

    // Освобождение памяти, занятой под очередь
    delete L2;
}
```

Следует отметить, что дерево может быть организовано не только как динамическая связная структура данных, но и как массив.
<br>
Например, при НИСХОДЯЩЕМ обходе начальный элемент массива оказывается КОРНЕМ дерева, а при ПОСЛЕДОВАТЕЛЬНОМ обходе – самым ЛЕВЫМ узлом (рисунок 9). 

Дерево Фенвика (двоичное индексированное дерево) – структура данных, позволяющая быстро изменять значения в массиве и находить некоторые функции от элементов

#### 1.3.3 Поиск узла в дереве
Поиск узла в дереве (в том числе в бинарном дереве поиска) может выполняться по такому же принципу, что и просмотр дерева. 

- ИЛИ использовать рекурсивные функции, например, с использованием  рассмотренных выше функций inorder, preorder
- ИЛИ отказаться от рекурсии.

```c++
// Рекурсивная функция поиска узла с ключом skey в дереве
// Принимает указатель на текущий узел (r), ключ для поиска (skey) и указатель на найденный узел (f)
void poisk1(node* r, int skey, node*& f) 
{
    // Если текущий узел r равен NULL или узел уже найден (f != NULL), завершаем рекурсию
    if (r == NULL || f)
        return;

    // Если ключ текущего узла r равен искомому ключу skey
    if (r->key == skey) 
    {
        f = r; // Устанавливаем указатель на найденный узел
        return; // Выходим из функции, так как узел найден
    } 
    else 
    {
        // Если искомый ключ меньше ключа текущего узла, рекурсивно вызываем поиск для левого поддерева
        if (skey < r->key) 
            poisk1(r->left, skey, f); 
        else
            // Иначе рекурсивно вызываем поиск для правого поддерева
            poisk1(r->right, skey, f);
    }
}
```

Третий аргумент node*& f – одновременно узел, в котором находятся найденные данные, и признак успеха поиска. 

Рекурсивные функции обладают одним недостатком: возможностью переполнения стека возврата из подпрограмм при большом количестве рекурсивных вызовов (а это может произойти при большом размере структуры данных).

Поиск с использованием нерекурсивной процедуры:

```c++
// Функция поиска узла с ключом skey в дереве с использованием цикла while
// Принимает указатель на текущий узел (r), ключ для поиска (skey) и указатель на найденный узел (f)
void poisk2(node* r, int skey, node*& f) 
{ 
    // Пока текущий узел r не равен NULL и узел еще не найден (f == NULL)
    while (r != NULL && f == NULL)
    {
        // Если ключ текущего узла r равен искомому ключу skey
        if (r->key == skey)
        {
            f = r; // Устанавливаем указатель на найденный узел
            return; // Выходим из функции, так как узел найден
        } 
        else 
        {
            // Если искомый ключ меньше ключа текущего узла, переходим к левому потомку
            if (skey < r->key)
                r = r->left; 
            else 
                // Иначе переходим к правому потомку
                r = r->right; 
        }
    }
}
```

Используя поиск узла, можно заменить рекурсивную процедуру добавления узла на нерекурсивную.
<br>
Для сбалансированного дерева, изображенного на рисунке 10, поиск аналогичен двоичному дереву – то есть, нужно просмотреть не более log2N узлов.

**Сбалансированное** двоичное дерево поиска - высота каждого из поддеревьев, имеющих общий корень, отличается не более чем на некоторую константу k

![image](https://github.com/mireashik/aood_3sem/assets/49165758/8a454aa4-fc43-4ef4-8883-1a0f5e1706cd)

Для вырожденного дерева (рисунок 11) поиск аналогичен поиску в односвязном списке – в среднем нужно просмотреть половину узлов, а в худшем случае – все N узлов.

**Вырожденное** дерево - каждый узел имеет 1 сына. Вырожденное бинарное дерево эквивалентно связанному списку

![image](https://github.com/mireashik/aood_3sem/assets/49165758/174bb724-491e-451a-b830-3d17d165bb45)

#### 1.3.4 Удаление узла из дерева
Удаление узла из дерева – существенно более сложный процесс, чем поиск. Наиболее простым случаем является удаление терминального узла.

Такой узел всегда существует. Это либо самый ЛЕВЫЙ узел правой ветви, либо самый ПРАВЫЙ узел левой ветви.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/7dc233b4-8b5b-45b1-ac4f-1ec024772cdf)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/a37f20e2-eeb3-4a61-9be7-36b9b333f187)

Процедура удаления узла должна различать три случая: 
1. Узла с данным ключом в дереве нет.
2. Узел с заданным ключом имеет не более одной ветви (рисунок 12)
3. Узел с заданным ключом имеет две ветви (рисунок 13)

```c++
// Вспомогательная функция для удаления узла с одним поддеревом
// Принимает указатели на текущий узел (r) и узел для переноса данных (q)
void del1(node*& r, node*& q) 
{ 
    // Если у текущего узла r нет правого поддерева
    if (r->right == NULL) 
    { 
        q->key = r->key; // Переносим данные
        q->data = r->data; 
        q = r; // Указатель q теперь указывает на узел, который нужно удалить
        r = r->left; // Устанавливаем левого потомка вместо удаляемого узла
    } 
    else
    {
        // Рекурсивно вызываем del1 для правого поддерева
        del1(r->right, q);
    }
}

// Функция удаления узла с ключом key из дерева
// Принимает указатель на корень дерева (d) и ключ для поиска (key)
void del_node(node*& d, int key)
{ 
    node* q; // Вспомогательный указатель для удаления
    // Если текущий узел d равен NULL, завершаем функцию
    if (d == NULL) 
        return; 
    else 
        // Если искомый ключ меньше ключа текущего узла, рекурсивно вызываем del_node для левого поддерева
        if (key < d->key) 
            del_node(d->left, key); 
        else if (key > d->key) // Иначе, если искомый ключ больше ключа текущего узла
            del_node(d->right, key); 
        else // Иначе искомый ключ совпадает с ключом текущего узла
        { 
            q = d; // Устанавливаем вспомогательный указатель q на удаляемый узел
            // Если у удаляемого узла нет правого поддерева
            if (q->right == NULL) 
                d = q->left; // Устанавливаем левого потомка вместо удаляемого узла
            else 
                // Если у удаляемого узла нет левого поддерева
                if (q->left == NULL) 
                    d = q->right; // Устанавливаем правого потомка вместо удаляемого узла
                else 
                    // Иначе вызываем del1 для удаления узла с двумя поддеревьями
                    del1(q->left, q); 
            delete q; // Удаляем узел
        } 
}
```

#### 1.3.5 Удаление всех узлов дерева
Эта операция выполняется по тому же принципу, что и просмотр дерева. Для этого случая можно использовать восходящий обход дерева. Восходящий (постфиксный или обратный) – проходится левая ветвь, затем правая, затем 
корень.

```c++
// Рекурсивная функция для удаления всех узлов в бинарном дереве
// Принимает указатель на корень дерева (r)
void del_all(node*& r) 
{ 
    // Если текущий узел r равен NULL, завершаем рекурсию
    if (!r)
        return; 

    // Рекурсивно вызываем del_all для левого поддерева
    del_all(r->left); 

    // Рекурсивно вызываем del_all для правого поддерева
    del_all(r->right); 

    // Удаляем текущий узел
    delete r;

    // Устанавливаем указатель на NULL для предотвращения использования удаленного узла
    r = NULL;
}
```

#### 1.3.6 Подсчёт узлов
Эта операция так же выполняется по тому же принципу, что и просмотр дерева. Только для этого случая необходимо воспользоваться нисходящим обходом дерева. Нисходящий (префиксный или прямой) – от корня к левой ветви, затем к правой.

```c++
// Рекурсивная функция для подсчета числа узлов в бинарном дереве
// Принимает указатель на текущий узел (r) и переменную для хранения результата (p)
void Nnodes(node* r, int& p) 
{ 
    // Если текущий узел r равен NULL, завершаем рекурсию
    if (r == NULL) 
        return; 

    // Увеличиваем счетчик узлов
    p++; 

    // Рекурсивно вызываем Nnodes для левого поддерева
    Nnodes(r->left, p); 

    // Рекурсивно вызываем Nnodes для правого поддерева
    Nnodes(r->right, p); 
}
```

#### 1.3.7 Определение высоты дерева
При подсчете числа уровней используется тот же принцип, что и при просмотре дерева.

```c++
// Рекурсивная функция для определения высоты бинарного дерева
// Принимает указатель на текущий узел (r), текущую высоту (p) и переменную для хранения результата (h)
void Height(node* r, int p, int& h) 
{ 
    // Если текущий узел r равен NULL, завершаем рекурсию
    if (r == NULL) 
        return; 

    // Увеличиваем текущую высоту
    p++; 

    // Проверяем, является ли текущий узел терминальным (листом)
    if (r->left == NULL && r->right == NULL)
    {
        // Если текущая высота больше текущей максимальной высоты, обновляем максимальную высоту
        if (p > h) 
            h = p; 
    }

    // Рекурсивно вызываем Height для левого поддерева
    Height(r->left, p, h); 

    // Рекурсивно вызываем Height для правого поддерева
    Height(r->right, p, h); 
}
```

Во многих алгоритмах обработки данных, хранящихся в деревьях, предполагается, что ключи узлов должны быть уникальными, иными словами, неповторяющимися.
<br>
На самом деле процедуры обработки дерева допускают существование повторяющихся ключей. Следует только помнить может быть найден не тот узел, который требовался, а первый встреченный узел с указанным ключом.

### 2. Дерево выражений
Бинарное дерево выражений - это бинарное дерево, чьи листья являются операндами, такими как константы или имена переменных, а другие узлы содержат операторы.

Например, постфиксная запись a b + c d e + * * приводит к следующему дереву выражений. 
<br>
Соответствующее инфиксное обозначение (a+b)*(c*(d+e)) может быть получено путем обхода дерева выражений

![image](https://github.com/mireashik/aood_3sem/assets/49165758/422c1b49-ff96-40fc-afcb-fa6c21ab25ae)

дерево выражений для 3 + ((5+9)*2) было бы:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/19cb8350-296e-4f9e-90a5-048456f4bc88)

Дерево выражений состоит из двоичных выражений. Но для унарного оператора одно поддерево будет пустым

Построение дерева выражений:
- Анализ и предоставление постфиксного выражения, для которого программа построит дерево выражений.
- Порядок обхода двоичного дерева/дерева выражений обеспечит инфиксное выражение данного ввода.

- Входные данные: A B C * + D/ - постфиксного выражения, для которого необходимо построить дерево выражений.
- Вывод: A + B * C / D – инфиксное выражение данного ввода.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/203f4fe0-7e5f-4ac4-bf33-3e58152c929a)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/5512e43c-c7c1-4d1d-89ca-a3cdb2783cfd)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/80492154-18a7-41e3-a524-0d72a410082b)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/f8c1700f-4a94-48e1-9d11-cf0119508fb1)

```c++
#include <bits/stdc++.h>
using namespace std;

// Класс для представления узла бинарного дерева
class node {
public:
    char value;
    node* left;
    node* right;
    node* next = NULL;

    // Конструктор с параметром для узла
    node(char c) : value(c), left(NULL), right(NULL) {}

    // Конструктор по умолчанию для узла
    node() : left(NULL), right(NULL) {}

    // Объявление класса Stack и expression_tree в качестве дружественных классов
    friend class Stack;
    friend class expression_tree;
};

// Класс стека для хранения узлов дерева
class Stack {
    node* head = NULL;

public:
    // Функции push и pop для управления стеком
    void push(node*);
    node* pop();

    friend class expression_tree;
};

// Класс для реализации обхода дерева
class expression_tree {
public:
    // Функция для обхода по порядку
    void inorder(node* x) {
        if (x == NULL)
            return;
        else {
            inorder(x->left);
            cout << x->value << " ";
            inorder(x->right);
        }
    }
};

// Реализация функции push для стека
void Stack::push(node* x) {
    if (head == NULL) {
        head = x;
    } else {
        x->next = head;
        head = x;
    }
}

// Реализация функции pop для стека
node* Stack::pop() {
    node* p = head;
    head = head->next;
    return p;
}

// Основная программа
int main() {
    // Постфиксное выражение
    string s = "ABC*+D/";
    Stack e;
    expression_tree a;
    node *x, *y, *z;
    int l = s.length();

    // Построение дерева из постфиксного выражения
    for (int i = 0; i < l; i++) {
        if (s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/') {
            z = new node(s[i]);
            x = e.pop();
            y = e.pop();
            z->left = y;
            z->right = x;
            e.push(z);
        } else {
            z = new node(s[i]);
            e.push(z);
        }
    }

    // Вывод обхода дерева по порядку
    cout << "The Inorder Traversal of Expression Tree: ";
    a.inorder(z);

    return 0;
}
```

Вывод: Порядок обхода дерева выражений: A + B * C / D

### 3.1 Сбалансированные деревья
Максимальный эффект использования бинарного дерева поиска достигается, в том случае, если дерево сбалансировано:
- когда все узлы, кроме терминальных, имеют непустые и правый и левый соседние узлы; 
- все поддеревья, начинающиеся с одного и того же уровня, имеют одинаковую высоту.

Сбалансированное бинарное дерево – максимально широкое и низкое. Именно такими являются деревья, показанные на рисунках 2, 5, 9 и 10. Фактически все эти деревья, кроме 5, являются идеально сбалансированными.

Идеально сбалансированное дерево, у которого для каждой вершины: число вершин в левом и правом поддеревьях различается не более чем на 1

Менее строгое, но практически более удобное определение сбалансированности дерева – дерево сбалансированное, если для каждого узла исходящие ветви отличаются по высоте не более, чем на один уровень.

1. В идеально сбалансированном дереве количество элементов левого и правого поддеревьев различается не более, чем на 1
2. В сбалансированном высота левого и правого поддеревьев различается не более, чем на 1.

Обратный случай – вырожденное дерево, – выродившееся в линейный односвязный список. Такое дерево получается, если заносимые в него данные упорядочены по возрастанию (рисунок 11) или по убыванию.

Вырожденные деревья также получили название лево- или правоассоциативных или "лоз"

Если данные случайны, то получается дерево, в той или иной степени приближающееся к сбалансированному

Для бинарного идеально сбалансированного дерева с максимально возможным (для идеальной сбалансированности) числом узлов существуют простые соотношения между этим числом узлов N и высотой дерева (то есть, числом уровней) h:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/c08622ce-4b29-47f1-95e4-44c1ebc8d0c9)

Состояние сбалансированности (хотя бы в менее строгом смысле) часто оказывается настолько важным для тех областей, в которых деревья применяются, что для достижения этого состояния принимают специальные меры. 

Такими мерами являются
<br>
ЛИБО та или иная операция балансировки (принудительной) дерева, в том числе включающая в себя упомянутые операции поворотов
<br>
ЛИБО использование специальных видов деревьев, обеспечивающих балансировку при каждой операции добавления или удаления узла.

Основными видами таких деревьев являются:
- АВЛ-дерево
- красно-черное дерево

### 3.2 АВЛ-дерево
АВЛ-дерево получило свое название по фамилиям его разработчиков – советских математиков Георгия Максимовича Адельсон-Вельского (родился 8 января 1922 г. в Самаре) и Евгения Михайловича Ландиса, которые предложили использовать такое дерево в 1962 году.

АВЛ-дерево полностью удовлетворяет менее строгому определению сбалансированности дерева:

Дерево сбалансированное, если для каждого узла исходящие ветви отличаются по высоте не более, чем на один уровень.

Сбалансированность достигается за счет упомянутых выше операций поворотов (или вращений)
<br>
для сравнения высот ветвей в каждом узле двоичного дерева поиска используется ДОПОЛНИТЕЛЬНОЕ ПОЛЕ – признак сбалансированности ветвей (или разность их высот).

![image](https://github.com/mireashik/aood_3sem/assets/49165758/14976fc8-5c7f-4806-b7cc-feb67920d58c)

### 3.3 Красно-черное дерево
Красно-черное дерево (RB-tree) отличается от АВЛ-дерева смыслом признака сбалансированности:

вместо разности высот ветвей используется абстрактный «цвет» (красный или черный) и дерево строится по следующим правилам, рассматриваемым ниже. 

1. Все указатели на терминальные узлы считаются непустыми (то есть в дереве имеются фиктивные терминальные узлы). 
2. Все такие терминальные узлы считаются «черными». 
3. Все узлы, соседние с «красными» узлами, считаются «черными» (то есть запрещена ситуация с двумя «красными» узлами подряд). 
4. В левой и правой ветвях дерева, ведущих от его корня к листьям, число «чёрных» узлов одинаково. Это число называется «черной высотой» дерева. 

![image](https://github.com/mireashik/aood_3sem/assets/49165758/0d078755-1909-485f-b3c6-0f46c3ae069a)

Теоретически считается, что красно-чёрное дерево требует меньшего объёма памяти для хранения отдельного узла, чем АВЛ-дерево, представления цвета достаточно всего одного бита
<br>
не всегда пригоден на практике, так как решаемая задача может не допускать такого разделения узлов.

Красно-чёрное дерево – один из видов самобалансирующихся двоичных деревьев поиска, гарантирующих логарифмический рост высоты дерева от числа узлов и позволяющее быстро выполнять основные операции дерева поиска: добавление, удаление и поиск узла

### 3.4. Вращения (повороты), используемы при балансировке

### 3.5. АВЛ-деревья и С++

#### 3.5.1 Понятие АВЛ-дерева

#### 3.5.2 Структура узлов АВЛ-дерева

#### 3.5.3 Балансировка узлов

#### 3.5.4 Вставка ключей

#### 3.6.5 Удаление ключей

### 3.6 В-деревья

### 3.7 Подробнее о В-деревьях или B-tree

#### 3.7.2 Структура

#### 3.7.3 Операции, выполнимые с B-деревом

**Добавление**

**Удаление**

**Базы данных**

### 3.8.1 Дерево Фибоначчи

### 3.8.2 Фибоначчиева куча
