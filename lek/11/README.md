## АЛГОРИТМЫ ВНУТРЕННЕЙ СОРТИРОВКИ
### 1.1. Сортировка кучей, пирамидальная сортировка (Heapsort)
Пирамидальная сортировка ‒ это алгоритм сортировки, в котором используется такая структура данных, как двоичная куча
<br>
неустойчивый алгоритм сортировки с временем работы O(NlogN)
<br>
использующий O(1) дополнительной памяти

**Законченное двоичное дерево** ‒ это двоичное дерево, в котором каждый уровень, за исключением, возможно, последнего, имеет полный набор узлов, и все листья расположены как можно левее

![image](https://github.com/mireashik/aood_3sem/assets/49165758/b95fd50c-0fdb-4293-b652-5d3c14d8f549)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/f94f7028-f6da-4b8a-af6b-7ab0815c7e26)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/55561b7a-8582-46de-9d53-becc03e595e0)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/43add3e4-b74b-4027-87e8-a12e724f47e1)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/823f398a-21eb-4753-b1f0-c5c6e838feaa)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/868c4bec-fc05-4329-96e3-e97767f6b240)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/73e411c5-69e0-4235-8a00-918f54d0cc23)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/8eefbd13-0d61-4704-84f5-aa13c10aaee8)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/fe886153-ece9-45e6-ac9f-a32a32d5e1d7)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/846499d3-304d-4bab-8b09-70f4af37e2a6)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/771cf7f9-23d7-449b-9f77-eb0e0f02a9a2)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/fa8ac42e-b04b-4116-b259-1d3b3110d131)

### 1.2. Сортировка TimSort
Сортировка Timsort (двоичное дерево) ‒ гибридный алгоритм сортировки, который сочетает в себе два алгоритма сортировки: сортировку вставками и сортировку слиянием

1. По специальному алгоритму разделяем входной массив на подмассивы.
2. Сортируем каждый подмассив обычной сортировкой вставками.
3. Собираем отсортированные подмассивы в единый массив с помощью модифицированной сортировки слиянием.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/8b63ae59-b2f7-498d-80aa-a512c73e5ec5)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/df5f6d98-fe8f-45ee-921e-069ed130282a)

Тим Петерс, ссылаясь на собственные эксперименты. показавшие, что $minrun > 256$ нарушается 1 пункт, а при $minrun < 8$ 2 пункт
<br>
если $N < 64$, тогда $N = minrun$ и алгоритм Timsort становится сортировкой вставками.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/47a4528d-edca-45d8-b58d-6ad97fb65f83)

Процедура слияния совершает обход и сравнение в зависимости от того, как расположены подмассивы. Таким образом, для реализации алгоритма необходимы процедуры обхода слева направо (если меньший массив находится слева) и справа налево (если меньший массив находится справа). На практике обычно ограничиваются первой процедурой и выбирают левый массив независимо от его размера ‒ это почти не влияет на скорость сортировки.

1. Создаётся временный массив в размере меньшего из соединяемых подмассивов.
2. Меньший из подмассивов копируется во временный массив.
3. Указатели текущей позиции ставятся на первые (последние) элементы большего и временного массива.
4. На каждом следующем шаге рассматривается значение текущих элементов в большем и временном массивах, берётся меньший (больший) из них и копируется в новый отсортированный массив. Указатель текущего элемента перемещается в массиве, из которого был взят элемент.
5. Пункт 4 повторяется, пока один из массивов не закончится.
6. Все элементы оставшегося массива добавляются в конец нового массива.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/edb434cd-b1d2-4cc0-a2ff-e1318dd00e8c)

A = {1, 2, 3,..., 9999, 10000}
<br>
B = {20000, 20001, ...., 29999, 30000}

В алгоритме Timsort используется модифицированная процедура слияния. Данная модификация получила названия «галоп». 

![image](https://github.com/mireashik/aood_3sem/assets/49165758/eae2b16f-7a21-4b01-9ea2-f5ac2a93c2ec)

Первые 7 итераций сравниваются числа 1, 2, 3, 4, 5, 6 и 7 из массива A с числом 20000, так как 20000 больше ‒ элементы массива A копируются в результирующий
<br>
со следующей итерации алгоритм переходит в режим «галопа»: сравнивает с числом 20000 последовательно элементы 8, 10, 14, 22, 38, $n+2^i$, …, 10000 массива A. ($~log^2 N$ сравнений)

minrun принадлежит диапазону [32;65). Почему это так? 

![image](https://github.com/mireashik/aood_3sem/assets/49165758/b92bbce8-7183-4297-9238-e4de9197c75d)

**сливаемые** массивы ВСЕГДА имеют примерно одинаковую длину

O(logN) операций слияния, а значит и каждый элемент будет задействован в сравнениях не более O(logN) раз

![image](https://github.com/mireashik/aood_3sem/assets/49165758/93a6f14d-e464-4a2d-b34c-2091d54a9bea)

при большом minrun слияний будет меньше, а сортировки вставками будут выполняться долго
<br>
оптимальный диапазон ‒ от 32 до 64

### 4.1.3. Сортировка с помощью двоичного дерева (Binary tree sort)
Построение двоичного дерева поиска по ключам, далее обход узлов дерева в необходимом порядке ключей 

**Двоичное дерево поиска** ‒ двоичное дерево с доп. условиями:
- оба поддерева ‒ левое и правое ‒ являются двоичными деревьями поиска
- Левее X - меньше X
- Правее X - больше или равно X

![image](https://github.com/mireashik/aood_3sem/assets/49165758/123da9eb-baad-4b9b-b603-6af8a0617cfb)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/bf611388-bcb7-4705-8b13-c7b4b5a2e5db)

Построим двоичное дерево поиска:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/90e3f233-bb81-4a78-9f28-915faa00595f)

Далее инфиксная форму обхода (симметричном порядке, слева направо):

![image](https://github.com/mireashik/aood_3sem/assets/49165758/51a6e163-8d3d-45d0-a8c5-6871f821fa93)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/03e38452-5161-452a-b65a-317d41711701)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/e968eecb-98fc-4df5-af3d-2881614c1537)

Строим в том же порядке, но по правилам дерева:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/2ec8af5c-309e-4b9d-b03a-7ca47b936df5)

Если входная последовательность уже отсортирована, то дерево выродится в линейный список

Если мы будем рекурсивно обходить дерево по правилу: «левый сын ‒ родитель - правый сын» (а это и есть инфиксная форма обхода) ‒ то будет упорядоченный массив

![image](https://github.com/mireashik/aood_3sem/assets/49165758/c32a42db-94fe-4cfc-a6af-d804558b6b4a)

## 1.4. Сортировка со свойствами элементов
### 1.4.1 Сортировка подсчётом
Есть ли алгоритмы сортировки со сложностью, меньшей O(NlogN)? Да, если использовать свойства ключей, можно за O(N)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/9c217943-9161-4176-b528-0d79fc22c70b)

Вводим массив:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/c97b698b-5587-4c3a-a6a8-86eaa2f287ce)

Массив F - i элемент показывает количество элементов значением i из исходного массива S

![image](https://github.com/mireashik/aood_3sem/assets/49165758/7ef1ea5c-11c3-4107-80e1-da8de6577a31)

Далее просто собираем новый массив:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/e0e45f1f-dc8d-4957-b7b0-da387967e94a)

Мы не применяли операций сравнения. Из-за этого сравнивать можно только целые числа. 

### Сортировка подсчётом: особенности
- Ключи должны быть перечислимы
- Требуется дополнительная память
- O(|D(K)|) + O(N)

### 1.4.2 Поразрядная сортировка
1 автоматизированная промышленная сортировка

перфокарты, карманы (линии), без использования операций сравнения 

![image](https://github.com/mireashik/aood_3sem/assets/49165758/b8daa6e2-783a-45a4-bcbd-cf1100b08c5a)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/3d85e41b-143d-40c5-8500-b5244c2e7175)

По 3 разряду:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/2eccccd8-a394-46e4-9f9c-7e6050d18ad6)

По 2 разряду:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/82cec072-c2db-4d7d-b160-1e6094aa644b)

По 1 разряду:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/b5b9adca-c2df-41f0-9b0e-806c9b3197bc)

3O(N)=O(N)

Стопку помещали в карман
<br>
После нажатия на кнопку - сортировка

Затем работник, не меняя порядка внутри перфокарт в кармане (устойчивая сортировка), собирал перфокарты в нужном порядке, получая тем самым частично отсортированную по ключу стопку
<br>
Затем переключатель устанавливался на предпоследнюю цифру ключа

- Требует ключи
- Требует дополнительной памяти
- Сложность постоянна

операция разделения числа на фрагменты  - медленная, быстрее использовать разделение на наборы битов или байтов

### 1.5. Сравнительный анализ методов внутренней сортировки
![image](https://github.com/mireashik/aood_3sem/assets/49165758/a940bc9a-04fb-4b60-b984-1a4610ac1a3a)

## 2. АЛГОРИТМЫ ВНЕШНЕЙ СОРТИРОВКИ
- Для сортируемых данных недостаточно быстрой оперативной памяти (HDD, SSD)
- Время сортировки превосходит приемлемые границы

при недостатке оперативной памяти - внешняя.

### 2.1. Внешняя сортировка слиянием
Абстракция «ЛЕНТА»

- create ‒ создать новую пустую ленту и открыть её с возможностью записи.
- open ‒ открыть существующую ленту исключительно для чтения.
- close ‒ перестать использовать ленту.
- getdata ‒ прочитать информацию с ленты.
- putdata ‒ записать информацию на ленту.

Повторим: сортировка слияния - каждый массив просматривается от начала до конца, и выходной массив пишется строго последовательно (поэтому подходит и для работ с лентами)

слияние двух лент - **двухпутевое слияние**
<br>
исходные - 2 отсортированные ленты, выходные ‒ 1 отсортированная лента

**чанк** (chunk) ‒ фрагмент данных, помещающихся в ОЗУ

![image](https://github.com/mireashik/aood_3sem/assets/49165758/382f2d14-37f1-4f86-a1c2-5751b6af740c)

На первом этапе считывается первый чанк, сортируется внутренней сортировкой и отправляется на первую временную ленту

![image](https://github.com/mireashik/aood_3sem/assets/49165758/4659358b-2ffe-43d8-a4dd-365f30acf9fb)

На втором этапе второй чанк сортируется

![image](https://github.com/mireashik/aood_3sem/assets/49165758/cedb3857-2ce9-49a6-8c06-38467d06a655)

На третьем этапе производится слияние обработанных чанков:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/d9d9499a-61e0-4463-8f04-7d44139bbbad)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/403f19d9-b002-4dd4-9dc8-dc9e2517b96d)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/1b67a8bf-81d7-4b1c-a279-48332eee0bff)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/e86ca322-bc16-4ffd-97fa-6bf6f8316538)

Для получения ленты 5678 требуется 4 временные ленты. Плюс лента 1234. Итого ‒ **5 лент**.

Сложность алгоритма с использованием внешней памяти не увеличилась ‒ и это **неплохо**.
<br>
Можно ли упростить алгоритм до такой степени, чтобы он не использовал большое количество лент?

Достаточно памяти для 2 элементов, давайте откажемся от большого буфера и чанков.

**Серии** ‒ возрастающие последовательности на ленте (всего 2 дополнительные ленты)

### 2.2. Сортировка сериями
![image](https://github.com/mireashik/aood_3sem/assets/49165758/0e4bcdd6-aa47-4373-a446-dcd73ef8bbb8)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/4eaa4e51-743d-4245-a7f8-cc1fe7ec5c07)

Формируем **пары** между сериями, каждую из пар упорядочиваем

Совокупная последовательность является серией удвоенной длины:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/86fd64c2-0d64-471f-9081-bcac5f4a5b7b)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/516e0c26-8efc-45e7-8b7c-561e83a68274)

Снова каждую из серий попарно сливаем в исходную ленту

![image](https://github.com/mireashik/aood_3sem/assets/49165758/55af52fb-706f-4475-8840-5d4913bd1a4f)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/fbaca47b-d1d0-40e3-9d8a-02e44e907ee8)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/7f150f4e-de19-4528-9c7f-911ae1b7c3be)

Разбивка:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/a1348178-7efe-4c5a-b2fb-5586435de159)

Слияние:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/e92415a1-1cb4-4b7c-83d7-4c3db1c2b90a)

для его работы вполне достаточно памяти всего для 2 элементов

### Сортировка сериями: оценка сложности алгоритма
![image](https://github.com/mireashik/aood_3sem/assets/49165758/f86306a6-cd39-4dbe-8f4c-f0fb05b08b93)
