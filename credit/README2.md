### 39. Графы: основные понятия и определения.
**Граф** ‒ множества вершин и множества соединяющих их рёбер. Граф G состоит из множества V.
<br>
Вершины v и w лежат на ребре e, ребро e инцидентно вершинам v и w.

- Смежность вершин - 2 вершины называются смежными, если они инцидентны 1 ребру
- Мультиграф - граф с кратными рёбрами
- Псевдомультиграф - граф с петлями и кратными рёбрами
- Изолированная вершина - вершина с 0 степенью
- Висячая вершина - вершина с 1 степенью
- Полный граф - каждые 2 вершины соединены одним ребром: $N * (N - 1) / 2$
- Регулярный граф - степени одинаковые для всех вершин.
- Двудольный граф - вершины графа можно разделить на 2 множества
- Связный граф - пара его вершин соединена маршрутом

![image](https://github.com/mireashik/aood_3sem/assets/49165758/f9630963-981e-47b4-8e5c-4e3193b1ce82)

### 40. Ориентированные и неориентированные графы. Остовные деревья
#### Неориентированные графы

Маршрут/цепь - последовательность различающихся вершин, каждая из которых является смежной по отношению к другой
<br>
Цикл - цепь более 3 вершин, начало = конец

![image](https://github.com/mireashik/aood_3sem/assets/49165758/dad209d4-85e3-4452-bd09-e87685e393b2)

#### Ориентированные графы
Сильносвязный граф - от любой вершины к любой другой вершине имеется направленный маршрут
<br>
Слабосвязный граф - при удалении ребер неориентированный граф получился связным

![image](https://github.com/mireashik/aood_3sem/assets/49165758/c3382b63-3154-4b8b-aa0c-73e5c4abd173)

#### Остовное дерево
Остовное дерево графа (или стягивающее, покрывающее дерево, каркас графа, скелет) - дерево со всеми вершинами исходного графа, без циклов и контуров

На связном графе можно построить более чем 1 остовное дерево
<br>
Для взвешенного графа существует по крайней мере 1 минимальное остовное дерево.

**Минимальное остовное дерево** (или минимальное покрывающее дерево) в (неориентированном) связном взвешенном графе ‒ остовное дерево с минимальным весом

вес дерева - сумма всех весов рёбер

Поиск минимального остовного дерева:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/22c8a937-8300-4eba-a626-bb7c61257c47)

### 41. Реализация графов.
Представление в виде **множества**

Есть 2 общих способа реализации множества вершин:
1. Представлении множества как списка его элементо
2. Способ - битовая строка, хранит булево значение (т.е. один бит) для каждого члена множества, имеется ли он в множестве или нет.

#### Таблицы смежности
![image](https://github.com/mireashik/aood_3sem/assets/49165758/2666a503-1a40-4a8a-850b-5d4f51653c70)

#### Списки смежности
Список смежности, каждой вершине графа соответствует список, состоящий из «соседей» этой вершины.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/d9882fe6-788a-4696-848b-ecf4ba21252a)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/985da0b0-ad24-4785-b31b-4d266917ad30)

#### Связная реализация
![image](https://github.com/mireashik/aood_3sem/assets/49165758/50ae6abe-5474-4787-928a-845937861608)

#### Непрерывная реализация
Поиск в связных списках оказывается весьма утомительным.

Иногда поиск в связных списках (выше) оказывается весьма утомительным.

**Валентность вершины** - число смежных с ней вершин.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/6c6e3241-8ff6-4ad6-92fb-09be617e3bf0)

#### Смешанная реализация
Непрерывный список - для вершин, связная память - для списков смежности

![image](https://github.com/mireashik/aood_3sem/assets/49165758/751dcf27-f4fa-44dc-b029-c3977e7bb925)

#### Информационные поля
Иногда необходима дополнительная информация о каждой вершины или каждого ребра
<br>
В связных списках - дополнительне поля
<br>
В непрерывных реализациях - через преобразования элементов массива

Особо важным примером является организация сети через веса рёбер. Тогда используем таблицу смежности, где веса, а не 0 или 1.

### 42. Методы просмотра графа в ширину. Алгоритм просмотра графа в глубину.
Исследовать все вершины графа (как было у двоичных деревьев), однако при просмотре дерева обычно есть корень, в графах корня нет. Просмотр 1 может начаться с любой произвольно взятой вершины.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/b0c24acf-44fb-486d-be74-8c98617fe41b)

### 43. Метод просмотра графа в ширину. Алгоритм просмотра графа в ширину.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/4482bf54-67e7-452b-ac17-962c3ecd0577)

### 44. Алгоритм экономного продвижения: кратчайшие маршруты.
![image](https://github.com/mireashik/aood_3sem/assets/49165758/ea5f9fb5-0218-47d7-9aa4-472c617b35a7)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/447d6207-ebbe-452f-8cdc-c10048e14828)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/ffc8d690-5535-4382-9870-c907842bcf27)

### 45. Остовное дерево. Минимальное остовное дерево. Свойства минимального остовного дерева.
![image](https://github.com/mireashik/aood_3sem/assets/49165758/87b54d6a-9e50-49a1-a12f-27e6427c842b)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/ba5e64a7-fdcd-4b00-859d-fe62e24294e7)

### 46. Задача о нахождении минимального остовного дерева: постановка и алгоритмы решения.
На задачу о нахождении минимального остовного дерева похожа ЗАДАЧА о **дереве Штейнера** - несколько точек на плоскости с мин. суммой длин путей (однако там разрешается добавлять дополнительные точки ветвления)

Типичное применение остовных деревьев минимальной стоимости можно найти при разработке коммуникационных сетей

Для нахождения минимального остовного дерева графа существуют 4 алгоритма:
- Алгоритм Прима (нередко в литературе встречается название этого алгоритма – **алгоритм Дейкстры-Прима**)
- Алгоритм Краскала (или алгоритм Крускала)
- Алгоритм Борувки
- Алгоритм обратного удаления (получение минимального остовного  дерева из связного рёберно взвешенного графа)

алгоритм Прима и алгоритм Крускала частные случаи алгоритма Борувки, все они для **неориентированных** графов

Чтобы не стрелять наугад и не искать лучший выбор, в **ЖАДНОМ** алгоритме выбирается лучший выбор на **текущий** момент. И мы надеемся что этот **локальный** выбор приведёт глобально к лучшему.
<br>
Динамическое программирование - решение сложной задачи путём разбиения их на более простые подзадачи

### 47. Поиск минимального остовного дерева: алгоритм Дейкстры-Прима.
Допустим начальная вершина будет А:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/ab9d0362-1a46-4fe6-98c9-e050b67f9ea1)

Все вершины, непосредственно связанные с А:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/6f173c66-4c4a-4983-b493-6f6cd0979a16)

Миниальное ребро с B, добавляем его в кайму:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/34985588-61ee-44f3-9dea-9cdb3d5dc9ff)

Из 5 рёбер минимальный вес BE (3):

![image](https://github.com/mireashik/aood_3sem/assets/49165758/940d78a2-1272-4ad4-b731-fabd0b4fff82)

Теперь смотрим вершину А, там минимальный вес 4:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/044969a1-5b40-4846-84ec-e3a97566c246)

Далее вершина F:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/d6fe5c1a-eb9d-47ba-812f-cd063fc5ed41)

Добавляем вершину D:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/4b51e163-c4ab-4032-a5ea-5e14e31fe534)

Осталось одна вершина G:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/7094034a-1e03-404d-9a89-d96c8d9a2491)

### 48. Поиск минимального остовного дерева: алгоритм Крускала.
Алгоритм Дейкстры-Прима начинает с конкретной вершины, **алгоритм Крускала** делает упор на рёбрах графа

![image](https://github.com/mireashik/aood_3sem/assets/49165758/1cb0ff27-2c69-4289-8e33-a95f31cf512d)

Начнём с ребра наименьшего веса 1:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/fb52b3b2-9e62-4993-a879-2e390c0f19b2)

Следующим добавляется ребро имеющее вес 2:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/95428c06-c16f-4d32-8e75-f0e6b5e007dd)

Добавляем ребро, имеющее вес 3:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/68c504ed-0386-4ac0-bb6c-3e8276d44df9)

И так далее:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/ae30479c-f120-4829-a91b-37e21f802a27)

Неприсоединённой осталась лишь вершина G. Но какое ребро выбрать? Некоторые рёбра приведут к циклу - **отбросим** их. Однако есть 2 ребра которые не создаст **циклов**, выбираем любое из них:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/e34564a0-1230-4fa8-8235-78f4a118581a)

### 49. Поиск минимального остовного дерева: алгоритм Борувки.

На каждом шаге для каждой вершины - выбирается ребро наименьшего веса. Некоторые рёбра при этом выбираются дважды, а некоторые лишь один раз. Все эти рёбра добавляются в остовное дерево, а в исходном графе все они стягиваются

![image](https://github.com/mireashik/aood_3sem/assets/49165758/0ca655f8-650e-4089-bc62-b0a00b805e9e)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/a8dd95d3-40da-407b-b468-b8aeb37ab99e)

Строится минимальный покрывающий лес, состоящий только из вершин, каждая из которых является КОМПОНЕНТОЙ СВЯЗНОСТИ

![image](https://github.com/mireashik/aood_3sem/assets/49165758/290b3502-d3ad-43f5-b6e5-15b20f19cce2)

Для каждой компоненты находим рёбра минимального веса:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/87af7b2b-0a91-434b-ba40-d3fcfd1480d4)

Добавляем найденные рёбра к минимальному оставному дереву:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/ec97266a-a503-4122-a61e-0c64f24c79a6)

Снова находим рёбра минимального веса:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/046c3d46-8db9-4649-acb0-1f9da6ff8754)

Добавляем:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/6b56657f-7eaf-401a-b741-a8daf3ba8d7b)

Расчёт окончен. Получилось 1 компонента связности. Осталось подсчитать минимальный остовный вес:
<br>
<Н1,Н2>+<Н2,Н5>+<Н3,Н5>+<Н5,Н4>+<Н5,Н7>+<Н4,Н6>+<Н4,П> = 4+4+3+2+5+5+2 = 25

![image](https://github.com/mireashik/aood_3sem/assets/49165758/67b0f4d3-0e0f-4f99-9b5d-ee5fbe79d553)

### 50. Поиск минимального остовного дерева: алгоритм обратного удаления.
Рассмотренные нами алгоритмы поиска минимального остовного дерева правильно работают для взвешенных, но исключительно **неориентированных** графов. 
<br>
Как быть в ориентированных графах?

#### Алгоритм Эдмондса (Чу‒Лью/Эдмондса)
Поиск минимального остовного дерева во взвешенном ориентированном графе с корнем в заданной вершине

Для каждой вершины (кроме корня) найдем ребро, которое будет входить в неё в ответе.
<br>
Для каждой вершины (кроме корня) найдем минимальное ребро, которое в неё входит и вычтем его вес из всех ребер, входящих в неё
<br>
В новом графе для каждой вершины (кроме корня) зафиксируем одно ребро нулевого веса

![image](https://github.com/mireashik/aood_3sem/assets/49165758/3878f61b-8d06-40c0-a3a0-a51ad40e2bf5)

Для каждой вершины исходного графа G найдём ребро минимального веса. 

- Для вершины А=>m(A)=1 – минимальный вес ребра, входящего в вершину А.
- Для вершины B=>m(B)=1 – минимальный вес ребра, входящего в вершину B.
- Для вершины C=>m(C)=1 – минимальный вес ребра, входящего в вершину C
- Для вершины D=>m(D)=1 – минимальный вес ребра, входящего в вершину D.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/398704a2-ad94-46d0-ac78-0efb763581bb)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/50386e68-9cc1-4d0a-8608-5424842b785c)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/f2348708-4951-4e36-8482-388bed1b21cc)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/ae14403f-1323-4eab-b45e-341f3027260a)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/3792f1cf-7797-4582-bbcf-a125f1f1f130)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/9a96ca57-aabc-4090-b8e1-ec8dc5796589)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/3a76f309-d3d2-49eb-b736-6f2b8296cf9a)

### 51. Задача поиска кратчайшего пути: постановка и алгоритмы решения.
**Алгоритма поиска кратчайшего пути** - последовательность ребер, соединяющая заданные две вершины и имеющая наименьшую длину среди всех таких последовательностей.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/f9864aa3-6c61-4ec6-baed-cf3859e4bbc7)

Алгоритм построения минимального остовного дерева выберет все ребра веса 1, отбросив единственное ребро веса 2:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/2b39c716-afb4-471a-b680-7f8ba09da2aa)

Ясно, что он не является кратчайшим, поскольку в исходном графе вершины А и В соединены ребром длины 2 (задача о дилижансе)
<br>
GPS-навигаторах

### 52. Поиск кратчайшего пути: алгоритм Дейкстры.
Кратчайшие пути от 1 вершины до всех остальных.
<br>
Оригинальный алгоритм Дейкстры - был только путь между 2 узлами
<br>
распространенный вариант фиксирует один узел как «исходный» - создаёт дерево кратчайших путей

Метка исходной вершины a полагается равной 0, метки остальных вершин ‒ бесконечности.
<br>
Если все вершины посещены, алгоритм завершается.

Смежные вершины выбираются по весу, в начале проходятся все вершины по весу начиная с исходной вершины.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/604d5ad3-4925-4685-a5ab-6c6ac3975943)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/581fdb7f-0eb4-4747-8f65-ebe9cae5411a)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/56ce9011-2b2a-4b03-9217-6989146cbb3e)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/53b7a042-11e9-4172-bf35-f825bd1e6173)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/7528991f-db5d-4bfe-844b-0d30a33df8ee)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/cc0ab59d-9ba2-4d92-9850-62d93be6f83d)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/09768965-4d1b-4acf-b3bf-6a5d25a4bf65)

Игнорируем плохие маршруты:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/8fbd50e0-e310-4848-9ff5-a4cc504987fb)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/92201727-edb0-4a1d-abcc-b45ec0091606)

работа алгоритма Дейкстры завершится

- 1→1=0
- 1→2=1
- 1→3=4
- 1→4=10
- 1→5=2
- 1→6=10

### 53. Поиск кратчайшего пути: алгоритм Беллмана-Форда.
От выделенной вершины-источника до всех остальных, применимость к графам с произвольными, в том числе **отрицательными** весами.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/9cc29d8a-d479-48dd-9081-04d8f99b95e1)

Все исходящие ребра записываются в таблице в алфавитном порядке:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/d8b93609-b7f5-403a-bf80-f61e0b600229)

Далее создаётся таблица - расстояние до каждой вершины и предыдущая вершина. Расстояние обозначено переменной d, а предыдущая вершина ‒ переменной π

![image](https://github.com/mireashik/aood_3sem/assets/49165758/715d2ac1-21c1-42d0-8e5c-fcf0820bd5fc)

путь через все рёбра. Всего рёбер 9, поэтому путь этот будет насчитывать до 9 итераций

![image](https://github.com/mireashik/aood_3sem/assets/49165758/bfe9a675-e125-4b00-b83a-fd98b145bcb2)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/4c3c2d18-3268-4925-828c-0e710dc5c663)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/90ccf042-0cca-4d6b-99f1-3b27fb73c938)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/2dc00d1d-e59c-4284-b370-1977eb3dc2c7)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/c5e4a66a-e4b6-497c-9e7a-a864c0d712a6)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/c922226c-78f8-4875-abb9-5b3403379bdf)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/c16e8b6e-ce44-402b-9eef-6bf207691e4f)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/d9853c5f-ae59-49d2-97f7-0caec7fe1603)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/27bd31a6-7bbf-4deb-9f82-5663b10cafde)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/d0a91b6c-ed99-40bf-9596-0a87f2481a05)

Если бы в этом графе существовал отрицательный цикл, то после $n-1$ итераций **алгоритм Беллмана-Форда** теоретически должен был бы найти кратчайшие пути ко всем вершинам

![image](https://github.com/mireashik/aood_3sem/assets/49165758/5395417b-43f4-46d0-a467-21c3b7fb5285)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/d73d5487-ff63-465e-b569-3d7056c4920c)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/29862b53-6cf9-4e19-8f91-60e5465ad980)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/45674637-e258-4407-8694-6a04212cfd32)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/bd6e457b-5449-4bcb-8bef-cf45fdab45be)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/8a9742e0-927d-40ea-b870-90e2c053bb0e)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/807ba2c2-da69-490d-9044-8bd3c9a8a190)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/b4effb77-be59-480c-8937-edd76478aad0)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/a16cdb17-a5e2-47b6-b99d-df707df6940c)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/ddbddd6a-fdd0-4c2f-a794-2c4045dde149)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/e435906a-3402-49b7-abc2-83d7b70185f6)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/763ea92e-120b-4b50-8032-7f80616d74ab)

### 54. Задача о максимальном потоке: постановка и алгоритмы решения
Нахождение потока по транспортной сети - сумма потоков из истока, или сумма потоков в сток **максимальна**.

Выделяются 2 вершины: 
- источник s;
- сток t.

Каждое ребро (u,v) ∈ E имеет **неотрицательную** пропускную способность

![image](https://github.com/mireashik/aood_3sem/assets/49165758/dbe58a3d-e8fc-49c5-9a47-4616e9635dfa)

Найти такой поток, где величина потока максимальна

Существуют различные алгоритмы решения задачи поиска максимального потока:
- **Линейное программирование**. Переменные - потоки по рёбрам, ограничения ‒ сохранение потока и ограничение пропускной способности. Сложность зависит от конкурентного алгоритма
- **Алгоритм Форда-Фалкерсона**. Находим любой увеличивающий путь. Увеличить поток по всем его рёбрам на минимальную из их остаточных пропускных способностей. Повторять, пока увеличивающий путь есть.
- **Алгоритм Эдмондса-Карпа**. Каждый раз выбирая кратчайший увеличивающий путь
- **Алгоритм Диница**. Усовершенствование алгоритма Эдмондса-Карпа (но хронологически был найден раньше), поиск в ширину, определяется расстояние от источника до всех вершин в остаточной сети
- **Алгоритм проталкивания предпотока**. Вместо потока алгоритм работает с предпотоком.
- **Алгоритм «поднять в начало»**.

### 55. Алгоритм Форда-Фалкерсона
Изначально величине потока присваивается значение 0
<br>
Затем величина потока итеративно увеличивается посредством поиска увеличивающего пути

Если искать не любой путь, а **кратчайший**, тол получится алгоритм **Эдмондса-Карпа**

- ШАГ 1. Обнуляем все потоки. Остаточная сеть изначально совпадает сисходной сетью.
- ШАГ 2. В остаточной сети находим **любой** путь из источника в сток. Если такого пути нет, останавливаемся.
- ШАГ 3. Пускаем через найденный путь (он называется увеличивающим путём или увеличивающей цепью) максимально возможный поток:
- - 3.1. На найденном пути в остаточной сети ищем ребро с **минимальной** пропускной способностью.
- - 3.2. Для каждого ребра на найденном пути увеличиваем поток на cmin, а в противоположном ему ‒ уменьшаем на cmin.
- - 3.3. Модифицируем остаточную сеть. Для всех рёбер на найденном пути, а также для противоположных (антипараллельных) им рёбер, вычисляем новую пропускную способность. Если она стала ненулевой, добавляем  ребро к остаточной сети, а если обнулилась, стираем его.
- ШАГ 4. Возвращаемся на шаг 2.
