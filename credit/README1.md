### 23. Деревья: основные понятия и определения
**Дерево** - узлы и рёбры (правил нет)
<br>
**Двоичное дерево** - каждый узел не более 2 потомков.

Двоичные деревья сочетают уникальности массив + связный список

Массив - медленное добавление / удаление, так как нужно переместить все элементы, что часто больше половины элементов
<br>
Связный список - медленный поиск, чтобы найти элемент нужно пройти по всем элементам

- Путь
- Корень
- Родитель
- Потомок
- Лист (терминальный узел)
- Поддерево
- Посещение
- Обход (все узлы)
- Уровни (поколения)
- Ключи (значения)

Частный случай - **двоичное дерево поиска** (сбора), где ключи правого дерева содержат в себе большие значения, ключи в левом - меньшие, и так выполняется рекурсивно.

Конечное корневое дерево T - связный ориентированный ациклический граф, с условиями:

- 1 вершина корень
- в каждую вершину 1 ребро
- из корня к любой вершине есть путь (единственный)

**Лес** - граф с несколькими деревьями
<br>
**Степень вершины deg** - число сыновей вершины (то есть у бинарного дерева степень не более 2!)
<br>
**Высота h** - максимальный уровень листьев

Упорядоченные деревья будут отличаться если вершины переставить местами (ниже деревья не равны):

![image](https://github.com/mireashik/aood_3sem/assets/49165758/55927eaf-92c2-4db5-9707-bc104e2c1ff1)

### 24. Представления деревьев
![image](https://github.com/mireashik/aood_3sem/assets/49165758/4003eac6-6954-486d-887c-f08c09871794)

Можно представить как связный список (данные и указатели на левый и правый потомок):

![image](https://github.com/mireashik/aood_3sem/assets/49165758/b2f209ca-9626-42d0-9e3f-c7f6c12b9f49)

Можно двигаться в дереве задом наперёд:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/a070d306-4b00-47ea-8bd6-611c76485100)

Проблемы будут если число сыновей у многих вершин слишком маленькое - сильно тратиться память, поэтому преобразуем лес в бинарное дерево

![image](https://github.com/mireashik/aood_3sem/assets/49165758/0e37cd9b-69a2-481e-83be-119ecd7ee165)

#### Дерево - массив
Дерево через линейный массив, a[i] - указатель на родитель узла:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/3d5fb472-39f3-41d3-aa4a-7e511d80e1c1)

#### Дерево - односвязный список
Дерево через связный список, список - потомки каждого узла:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/a9cf7cff-4fa8-4876-b261-258bb7666ab7)

Можно перейти от индекса массива к индексу ячейки массива:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/dd4cc84d-f758-48fd-bd79-6057064d5cf4)

### 25. Прохождение дерева в прямом порядке. Псевдокод прохождения дерева в прямом порядке
**Прохождение** - пошаговый перебор всех элементов дерева.

может выполняться с разными целями:
- просмотр (вывод на дисплей)
- сохранение в файл
- поиск

----------
Прохождение дерева может выполняться по методам:
- «в глубину»
- «в ширину»

Существует 3 способа прохождения дерева в ГЛУБИНУ:
- Последовательный (он же инфиксный, симметричный, поперечный) – дерево проходится, начиная с левой ветви вверх к корню, затем к правой ветви.
- Нисходящий (префиксный или прямой) – от корня к левой ветви, затем к правой.
- Восходящий (постфиксный или обратный) – проходится левая ветвь, затем правая, затем корень.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/c3d985b2-55ed-42f0-8bed-6e71e66ec8f7)

Последовательный способ удобен для сортировки данных.
<br>
Нисходящий способ удобен для сохранения дерева
<br>
Восходящий обход может использоваться при полном удалении всего дерева

Обход бинарного дерева поиска в ШИРИНУ выполняется с помощью вспомогательной структуры данных – очереди или стека.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/f0e2bef8-ce0c-4bc2-b719-6064051988b9)

Следует отметить, что дерево может быть организовано не только как динамическая связная структура данных, но и как массив.

**Дерево Фенвика** (двоичное индексированное дерево) – структура данных, позволяющая быстро изменять значения в массиве и находить некоторые функции от элементов

-------

Всего 4 обхода:

- **Прямой** (от корня до правого потомка, в глубину) - обход сначала предок, потом потомок (сын)
- **Обратный** (от левого потомка до корня, снизу вверх) - сначала потомки, потом предки
- **Симметричный** (обход слева направо по уровням, только для бинарных) - сначала обратный обход левое поддерево, затем корень, затем правое поддерево
- **Горизонтальный** (обход по высоте уровней, в ширину) - обход уровень за уровнем, слева направо

![image](https://github.com/mireashik/aood_3sem/assets/49165758/3425b08b-00fd-4aa1-b530-4f1a80ecbfb2)

При нумерации в прямом порядке все вершины поддерева с корнем r имеют номера, не меньшие r. Можно будет понять вершина w потомок для v или нет.

### 26. Прохождение дерева в обратном порядке. Псевдокод прохождения дерева в обратном порядке
![image](https://github.com/mireashik/aood_3sem/assets/49165758/97c0c655-4cd1-46ab-b418-ccf1d6599cae)

Прямой и обратный порядок прохождения деревьев используется в компиляторах для преобразования арифметических и логических выражений в бесскобочную запись (прямая и обратная польская запись).

![image](https://github.com/mireashik/aood_3sem/assets/49165758/0b5b069d-3575-42f3-917e-85242937bc7f)

### 27. Прохождение дерева в симметричном порядке. Псевдокод прохождения дерева в симметричном порядке
![image](https://github.com/mireashik/aood_3sem/assets/49165758/35df0a26-4ad6-4651-b0b1-b0e3447a00d4)

### 28. Прохождение дерева в горизонтальном порядке. Псевдокод прохождения дерева в горизонтальном порядке
![image](https://github.com/mireashik/aood_3sem/assets/49165758/c559b60a-d133-4f32-94bc-7ebf832dd577)

### 29. Бинарное дерево. Сбалансированное дерево и алгоритм его создания из N узлов
Бинарное дерево - не более 2 потомков для каждой вершины

**Строгое бинарное** - каждый **ровно** 2 потомка, заполняется **слева** направо

![image](https://github.com/mireashik/aood_3sem/assets/49165758/cb5cb3ed-1391-459a-a821-ed7a6fe48414)

**Сбалансированное дерево** (_АВЛ-дерево, ЧБ-дерево_) - для каждой вершины $v$ высота её 2 поддеревьев различается не более чем на 1.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/9c4d288f-8a2f-43e4-b735-993775dbed28)

**Идеально сбалансированное** - если все уровни **полностью** заполнены, кроме возможно последнего, число левых и правых деревьев меньше чем на 1

![image](https://github.com/mireashik/aood_3sem/assets/49165758/aaa2442d-ab56-4804-a8ef-b7bb3d5c325a)

Двоичное дерево поиска (_не путать с тем что выше, там уже про значение вершин!_) - если любая вершина $v$ содержит в левом поддереве вершины - $< v$, правое поддерево - $> v$

**Вырожденное дерево** - каждый узел имеет 1 сына. Вырожденное бинарное дерево эквивалентно связанному списку

![image](https://github.com/mireashik/aood_3sem/assets/49165758/9e8b83c7-6c3f-45bf-901f-a5bc614e082a)

### 30. Способы реализации бинарного дерева
![image](https://github.com/mireashik/aood_3sem/assets/49165758/79e3dcc7-edef-4bcf-a158-b181cb02b692)

- Класс, узел с указателями на левого и правого потомков (Node with Pointers)
- Массив (Array Representation)
- Список списков (List of Lists)

### 31. Бинарное дерево поиска. Операция вставки нового узла в дерево. Записать на абстрактном уровне
С числом ветвей $> 2$ – часто такие деревья называют **мультивариантными** (многопутевыми, сильноветвящимися) или **K-деревьями** (K-мерными).
<br>
B-деревья (различные деревья Байера-МакКрейта с вариантами, например, 2-3-деревья, 2-3-4-деревья) и тому подобное.

Автоматическая балансировка дерева выполняется, например, для АВЛ-деревьев, красно-черных деревьев

**Пирамида (в общем случае дерево поиска)** («куча, сортирующее дерево поиска») – значения всех узлов, размещённых на 1 уровне, больше (или меньше) значений узлов, размещенных на вышележащем уровне, **больше 1 уровень - дерево поиска.**
<br>
**Бинарное (двоичное) дерево поиска** (сбора) - частный случай пирамиды, где ключи **правого** дерева содержат в себе большие значения, ключи в **левом** - меньшие, и так выполняется рекурсивно.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/158e4d64-0fdd-445d-8c68-0f3939c15072)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/dbf37ef4-bcc8-4e63-b9da-6d1a13de40f4)

Обладает 3 условиями:
- Значение в любой вершине не меньше, чем значения её потомков.
- Глубина всех листьев (расстояние до корня) отличается не более чем на 1 слой.
- Последний слой заполняется слева направо без «дырок».

В дальнейшем под двоичными деревьями будут подразумеваться именно двоичные деревья поиска.

В чём отличие бинарных деревьев от двусвязного списка? Бывают случаи, когда они ничем не отличаются. 

Однако память - линейна, узел дерева хранится в памяти так:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/67e8ec31-8bbe-4c3e-abd3-2585b6e9d580)

Двоичное дерево в памяти:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/01732abf-4f1a-4eda-bf49-2e6fe610eec5)

- добавление элемента
- удаление
- прохождение (просмотр)
- поиск элементов
- принудительной балансировки
- подсчета числа узлов в дереве
- измерения высоты дерева
- поиска ближайшего общего корня

При балансировке деревьев используются операции поворотов (вращений), простых и двойных, левых и правых.

#### Добавление узла в дерево
![image](https://github.com/mireashik/aood_3sem/assets/49165758/b19ce28d-5164-4ab6-af07-7e3577c2ccbc)

**Поиск нужного места - потом добавление.**

При поступлении записи с ключом k, ключ сравнивают, начиная с корня, с ключом очередного узла. В зависимости от результата **сравнения**, процесс продолжают в **левой** или **правой** ветви пока не будет достигнут один из узлов, с которым можно связать входящую запись.

### 32. Бинарное дерево поиска. Операция удаления узла, имеющего одно поддеревом. Записать на абстрактном уровне
![image](https://github.com/mireashik/aood_3sem/assets/49165758/7d53ebeb-4b54-4d7a-9ce7-8e5c5b1974fd)

Удаление узла из дерева – существенно более сложный процесс. Наиболее простым случаем является удаление терминального узла.

Такой узел всегда существует. Это либо самый ЛЕВЫЙ узел правой ветви, либо самый ПРАВЫЙ узел левой ветви.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/eb4b430e-a79b-42e3-8512-bff8acb72242)

Процедура удаления узла должна различать три случая:

- Узла с данным ключом в дереве нет.
- Узел с заданным ключом имеет не более одной ветви (рисунок 12)
- Узел с заданным ключом имеет две ветви (рисунок 13)

```c++
function удалитьУзел(X, дерево):
    если X - корень дерева
        заменить корень левым или правым поддеревом
    иначе если X - левый потомок родителя
        заменить левый потомок левым или правым поддеревом
    иначе если X - правый потомок родителя
        заменить правый потомок левым или правым поддеревом

    освободить память, занимаемую узлом X
```

#### Удаление всех узлов дерева (как вывод но слева, а не справа)
Эта операция выполняется по тому же принципу (**слева-направо, потом корень**), что и просмотр дерева. Для этого случая можно использовать восходящий обход дерева. Восходящий (постфиксный или обратный) – проходится левая ветвь, затем правая, затем корень.

### 33. Алгоритм удаления узла с двумя поддеревьями из бинарного дерева поиска
Алгоритм удаления узла с двумя поддеревьями из бинарного дерева поиска (BST) включает в себя несколько шагов. В таком случае, мы должны найти узел, который заменит удаляемый узел. Этот узел обычно называется "преемником" или "предшественником". Преемник — это узел с наименьшим ключом в правом поддереве удаляемого узла. Вот алгоритм удаления узла с двумя поддеревьями:

1. **Найти преемника:**
   - Перейти вправо от удаляемого узла.
   - Затем идти влево, пока не достигнем самого левого узла.
   - Преемник — это самый левый узел в правом поддереве удаляемого узла.

2. **Скопировать данные преемника в удаляемый узел:**
   - Скопировать данные (ключ, значения и т. д.) преемника в удаляемый узел.
   - Теперь удаляемый узел фактически содержит данные преемника.

3. **Удалить преемника:**
   - Удалить преемника, который теперь находится вместо удаляемого узла.
   - Преемник имеет, как правило, одно поддерево, поэтому это становится аналогичной ситуацией удаления узла с одним поддеревом.

Алгоритм на псевдокоде:

```plaintext
function удалитьУзелСДвумяПоддеревьями(удаляемый, дерево):
    если удаляемый - корень дерева
        преемник = найтиПреемника(удаляемый.правое_поддерево)
        скопироватьДанныеУзла(преемник, удаляемый)
        удалитьУзел(преемник, удаляемый.правое_поддерево)
    иначе
        преемник = найтиПреемника(удаляемый.правое_поддерево)
        скопироватьДанныеУзла(преемник, удаляемый)
        удалитьУзел(преемник, удаляемый.правое_поддерево)

function найтиПреемника(поддерево):
    пока поддерево.левое_поддерево не равно None
        поддерево = поддерево.левое_поддерево
    вернуть поддерево

function скопироватьДанныеУзла(откуда, куда):
    куда.ключ = откуда.ключ
    куда.значение = откуда.значение
    куда.левое_поддерево = откуда.левое_поддерево
    куда.правое_поддерево = откуда.правое_поддерево

function удалитьУзел(удаляемый, поддерево):
    если удаляемый - левый потомок
        поддерево.левое_поддерево = None
    иначе
        поддерево.правое_поддерево = None
```

### 34. Реализация алгоритма вывода бинарного дерева поиска (от правого узла).
Бинарное дерево поиска и выведем его с помощью алгоритма "вправо-корень-влево":

```plaintext
      4
     / \
    2   6
   / \ / \
  1  3 5  7
```

При обходе вправо-корень-влево вывод будет следующим: `7 6 5 4 3 2 1`

Вы можете представить, что начинаете с самого правого узла и двигаетесь влево, посещая каждый узел и выводя его ключ.

Если у вас есть возможность выполнить код на Python, то вы можете скопировать приведенный выше пример кода и выполнить его для визуализации бинарного дерева.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/60caee15-90da-4a21-a66c-86b02e541854)

### 35. АВЛ-дерево. Структура узла. Алгоритм вставки нового узла в дерево.
