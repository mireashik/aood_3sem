### 23. Деревья: основные понятия и определения
**Дерево** - узлы и рёбры (правил нет)
<br>
**Двоичное дерево** - каждый узел не более 2 потомков.

Двоичные деревья сочетают уникальности массив + связный список

Массив - медленное добавление / удаление, так как нужно переместить все элементы, что часто больше половины элементов
<br>
Связный список - медленный поиск, чтобы найти элемент нужно пройти по всем элементам

- Путь
- Корень
- Родитель
- Потомок
- Лист (терминальный узел)
- Поддерево
- Посещение
- Обход (все узлы)
- Уровни (поколения)
- Ключи (значения)

Частный случай - **двоичное дерево поиска** (сбора), где ключи правого дерева содержат в себе большие значения, ключи в левом - меньшие, и так выполняется рекурсивно.

Конечное корневое дерево T - связный ориентированный ациклический граф, с условиями:

- 1 вершина корень
- в каждую вершину 1 ребро
- из корня к любой вершине есть путь (единственный)

**Лес** - граф с несколькими деревьями
<br>
**Степень вершины deg** - число сыновей вершины (то есть у бинарного дерева степень не более 2!)
<br>
**Высота h** - максимальный уровень листьев

Упорядоченные деревья будут отличаться если вершины переставить местами (ниже деревья не равны):

![image](https://github.com/mireashik/aood_3sem/assets/49165758/55927eaf-92c2-4db5-9707-bc104e2c1ff1)

### 24. Представления деревьев
![image](https://github.com/mireashik/aood_3sem/assets/49165758/4003eac6-6954-486d-887c-f08c09871794)

Можно представить как связный список (данные и указатели на левый и правый потомок):

![image](https://github.com/mireashik/aood_3sem/assets/49165758/b2f209ca-9626-42d0-9e3f-c7f6c12b9f49)

Можно двигаться в дереве задом наперёд:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/a070d306-4b00-47ea-8bd6-611c76485100)

Проблемы будут если число сыновей у многих вершин слишком маленькое - сильно тратиться память, поэтому преобразуем лес в бинарное дерево

![image](https://github.com/mireashik/aood_3sem/assets/49165758/0e37cd9b-69a2-481e-83be-119ecd7ee165)

#### Дерево - массив
Дерево через линейный массив, a[i] - указатель на родитель узла:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/3d5fb472-39f3-41d3-aa4a-7e511d80e1c1)

#### Дерево - односвязный список
Дерево через связный список, список - потомки каждого узла:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/a9cf7cff-4fa8-4876-b261-258bb7666ab7)

Можно перейти от индекса массива к индексу ячейки массива:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/dd4cc84d-f758-48fd-bd79-6057064d5cf4)

### 25. Прохождение дерева в прямом порядке. Псевдокод прохождения дерева в прямом порядке
**Прохождение** - пошаговый перебор всех элементов дерева.

Всего 4 обхода:

- **Прямой** (от корня до правого потомка, в глубину) - обход сначала предок, потом потомок (сын)
- **Обратный** (от левого потомка до корня, снизу вверх) - сначала потомки, потом предки
- **Симметричный** (обход слева направо по уровням, только для бинарных) - сначала обратный обход левое поддерево, затем корень, затем правое поддерево
- **Горизонтальный** (обход по высоте уровней, в ширину) - обход уровень за уровнем, слева направо

![image](https://github.com/mireashik/aood_3sem/assets/49165758/3425b08b-00fd-4aa1-b530-4f1a80ecbfb2)

При нумерации в прямом порядке все вершины поддерева с корнем r имеют номера, не меньшие r. Можно будет понять вершина w потомок для v или нет.

### 26. Прохождение дерева в обратном порядке. Псевдокод прохождения дерева в обратном порядке
![image](https://github.com/mireashik/aood_3sem/assets/49165758/97c0c655-4cd1-46ab-b418-ccf1d6599cae)

Прямой и обратный порядок прохождения деревьев используется в компиляторах для преобразования арифметических и логических выражений в бесскобочную запись (прямая и обратная польская запись).

![image](https://github.com/mireashik/aood_3sem/assets/49165758/0b5b069d-3575-42f3-917e-85242937bc7f)

### 27. Прохождение дерева в симметричном порядке. Псевдокод прохождения дерева в симметричном порядке
![image](https://github.com/mireashik/aood_3sem/assets/49165758/35df0a26-4ad6-4651-b0b1-b0e3447a00d4)

### 28. Прохождение дерева в горизонтальном порядке. Псевдокод прохождения дерева в горизонтальном порядке
![image](https://github.com/mireashik/aood_3sem/assets/49165758/c559b60a-d133-4f32-94bc-7ebf832dd577)

### 29. Бинарное дерево. Сбалансированное дерево и алгоритм его создания из N узлов
Бинарное дерево - не более 2 потомков для каждой вершины

**Строгое бинарное** - каждый **ровно** 2 потомка, заполняется **слева** направо

![image](https://github.com/mireashik/aood_3sem/assets/49165758/cb5cb3ed-1391-459a-a821-ed7a6fe48414)

**Сбалансированное дерево** (_АВЛ-дерево, ЧБ-дерево_) - для каждой вершины $v$ высота её 2 поддеревьев различается не более чем на 1.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/9c4d288f-8a2f-43e4-b735-993775dbed28)

**Идеально сбалансированное** - если все уровни **полностью** заполнены, кроме возможно последнего, число левых и правых деревьев меньше чем на 1

![image](https://github.com/mireashik/aood_3sem/assets/49165758/aaa2442d-ab56-4804-a8ef-b7bb3d5c325a)

Двоичное дерево поиска (_не путать с тем что выше, там уже про значение вершин!_) - если любая вершина $v$ содержит в левом поддереве вершины - $< v$, правое поддерево - $> v$

### 30. Способы реализации бинарного дерева
![image](https://github.com/mireashik/aood_3sem/assets/49165758/79e3dcc7-edef-4bcf-a158-b181cb02b692)

- Класс, узел с указателями на левого и правого потомков (Node with Pointers)
- Массив (Array Representation)
- Список списков (List of Lists)

### 31. Бинарное дерево поиска. Операция вставки нового узла в дерево. Записать на абстрактном уровне
С числом ветвей $> 2$ – часто такие деревья называют **мультивариантными** (многопутевыми, сильноветвящимися) или **K-деревьями** (K-мерными).
<br>
B-деревья (различные деревья Байера-МакКрейта с вариантами, например, 2-3-деревья, 2-3-4-деревья) и тому подобное.

Автоматическая балансировка дерева выполняется, например, для АВЛ-деревьев, красно-черных деревьев

**Пирамида (в общем случае дерево поиска)** («куча, сортирующее дерево поиска») – значения всех узлов, размещённых на 1 уровне, больше (или меньше) значений узлов, размещенных на вышележащем уровне, **больше 1 уровень - дерево поиска.**
<br>
**Бинарное (двоичное) дерево поиска** (сбора) - частный случай пирамиды, где ключи **правого** дерева содержат в себе большие значения, ключи в **левом** - меньшие, и так выполняется рекурсивно.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/158e4d64-0fdd-445d-8c68-0f3939c15072)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/dbf37ef4-bcc8-4e63-b9da-6d1a13de40f4)

Обладает 3 условиями:
- Значение в любой вершине не меньше, чем значения её потомков.
- Глубина всех листьев (расстояние до корня) отличается не более чем на 1 слой.
- Последний слой заполняется слева направо без «дырок».

В дальнейшем под двоичными деревьями будут подразумеваться именно двоичные деревья поиска.

В чём отличие бинарных деревьев от двусвязного списка? Бывают случаи, когда они ничем не отличаются. 

Однако память - линейна, узел дерева хранится в памяти так:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/67e8ec31-8bbe-4c3e-abd3-2585b6e9d580)

Двоичное дерево в памяти:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/01732abf-4f1a-4eda-bf49-2e6fe610eec5)

- добавление элемента
- удаление
- прохождение (просмотр)
- поиск элементов
- принудительной балансировки
- подсчета числа узлов в дереве
- измерения высоты дерева
- поиска ближайшего общего корня
