### 1 Структура данных (определение, назначение). Классификация структур данных. Характеристики.
**Структура данных (определение, назначение):**

Структура данных представляет собой организацию и хранение данных в компьютере таким образом, чтобы к ним можно было эффективно обращаться и выполнять различные операции. Она определяет способ организации и взаимосвязи между элементами данных, а также операции, которые можно выполнять с этими данными.

**Назначение структур данных:**

- **Эффективность:** Оптимизация использования памяти и времени выполнения операций.
- **Организация данных:** Позволяет группировать данные по определенным правилам для удобства и эффективности работы программы.
- **Облегчение алгоритмов:** Структуры данных предоставляют эффективные способы организации данных, что упрощает реализацию и оптимизацию алгоритмов.

**Классификация структур данных:**

1. **Линейные структуры данных:**
   - **Списки (List):** Упорядоченный набор элементов.
   - **Стек (Stack):** Структура данных с принципом Last In, First Out (LIFO).
   - **Очередь (Queue):** Структура данных с принципом First In, First Out (FIFO).

2. **Нелинейные структуры данных:**
   - **Граф (Graph):** Сеть связанных узлов (вершин) и ребер, описывающих отношения между ними.
   - **Дерево (Tree):** Структура данных, состоящая из узлов, связанных ребрами, при этом каждый узел имеет ровно одного родителя (за исключением корня) и может иметь несколько детей.

3. **Табличные структуры данных:**
   - **Массив (Array):** Упорядоченная коллекция элементов, доступ к которым осуществляется по индексу.
   - **Матрица (Matrix):** Двумерный массив, представляющий собой таблицу с элементами, расположенными в строках и столбцах.

**Характеристики структур данных:**

1. **Эффективность по времени:** Время, необходимое для выполнения операций (вставка, удаление, поиск и т. д.).
2. **Эффективность по памяти:** Использование ресурсов памяти для хранения данных и связанных структур.
3. **Простота использования:** Удобство работы с данной структурой данных в контексте конкретной задачи.
4. **Гибкость:** Возможность приспособления к различным сценариям использования.

### 2. Массивы: определение, классификация и основные поддерживаемые методы. Реализация поддерживаемых методов.
**Массив** - структура данных, состоящую из элементов 1 типа, расположенных в памяти последовательно и доступных по индексам. Элементы массива имеют одинаковый размер.

**Классификация:**

1. **Одномерные массивы (One-dimensional arrays):** Список элементов, расположенных в одном ряду. Доступ к элементам осуществляется по одному индексу.
2. **Двумерные массивы (Two-dimensional arrays):** Таблица элементов, разбитая на строки и столбцы. Доступ к элементам осуществляется по двум индексам (строка и столбец).
3. **Многомерные массивы (Multidimensional arrays):** Массивы с более чем двумя измерениями.

**Основные поддерживаемые методы:**
1. **Инициализация массива:** Создание массива и заполнение его элементами.
2. **Чтение элемента по индексу:** Получение значения элемента по указанному индексу.
3. **Запись элемента по индексу:** Установка значения элемента по указанному индексу.
4. **Поиск элемента:** Поиск элемента в массиве и возвращение его индекса.
5. **Добавление элемента:** Добавление нового элемента в массив.
6. **Удаление элемента:** Удаление элемента из массива.

### 3. Вектор: определение и основные поддерживаемые методы. Реализация поддерживаемых методов.
**Вектор: определение и основные поддерживаемые методы**

Вектор - упорядоченный набор элементов, которые могут использоваться для представления различных величин, например, координат точек в пространстве. Векторы могут быть одномерными (скаляры) или многомерными.

**Основные поддерживаемые методы:**
1. **Инициализация вектора:** Создание вектора и заполнение его элементами.
2. **Доступ к элементам вектора:** Получение значения элемента по индексу.
3. **Запись элементов вектора:** Установка значения элемента по указанному индексу.
4. **Сложение векторов:** Покомпонентное сложение элементов двух векторов.
5. **Умножение вектора на число:** Умножение каждого элемента вектора на заданное число.
6. **Скалярное произведение векторов:** Сумма произведений соответствующих элементов двух векторов.

### 4. Связной список. Операции над списками.
Связный список - структура данных, каждый элемент содержит информацию о следующем элементе. По сравнению с массивом - эффективное изменения расположения элементов. Хуже доступ к элементу списка (надо проходить по всему списку от начала)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/35ee6aee-c277-404e-a559-667ebe9b677c)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/c97e91f9-1e05-4446-9427-39963d32e447)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/91b93261-1085-438c-9e34-0858fc4ecd0a)

### 5. Реализация связных списков и основных операций над ними с помощью массива.
![image](https://github.com/mireashik/aood_3sem/assets/49165758/2a604421-4164-4ba2-8fda-7f6a16ee432b)

2 массива
<br>
В массиве **info** хранятся элементы множества
<br>
В массиве **next** указатели, индексы позиций в массивах, где расположены последующие элементы.

Вместо нескольких массивов, можно использовать 1 массив:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/a7bceb2e-79ca-4aad-986e-79e61092d122)

### 6. Реализация связных списков и основных операций над ними с помощью указателя.
Список состоит из ячеек и указателя, на следующую ячейку списка

![image](https://github.com/mireashik/aood_3sem/assets/49165758/96519e5c-fc33-4d75-9851-13b27ff1d015)

### 7. Классификация связных списков.
**Линейный список**

![image](https://github.com/mireashik/aood_3sem/assets/49165758/77949f6d-af6a-4e37-ada5-af1cfae02e8c)

**Линейный односвязный список**

![image](https://github.com/mireashik/aood_3sem/assets/49165758/d3164e58-ddec-4d10-b12b-5c08f6f926dd)

**Связный список с заголовками **(фиктивный элемент в начале)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/1493c1eb-7aa4-4f45-b6cd-20b7d668015c)

Упрощение включения и исключения

**Линейный двусвязный список**
![image](https://github.com/mireashik/aood_3sem/assets/49165758/44c58ae4-1ee0-46d4-bc37-66abbfa09be7)

**Циклический список**
![image](https://github.com/mireashik/aood_3sem/assets/49165758/3797cab1-fc32-43c6-8de3-32b7dd458938)

**Односвязный циклический список**
![image](https://github.com/mireashik/aood_3sem/assets/49165758/5e745dd8-edef-42e3-9049-b51a58f0b948)

**Двусвязный циклический список**
![image](https://github.com/mireashik/aood_3sem/assets/49165758/e187bb24-8148-4597-ba3a-4077b3c70454)

### 8. Алгоритмы и абстрактный тип данных.
**Алгоритм** – конечный набор правил, последовательность операций для решения задачи.

Частичный алгоритм - для некоторых d ∈ D, полный алгоритм - для всех d ∈ D

#### Формальные свойства алгоритмов
- полезность (умение решать)
- дискретность (последовательность решения)
- детерменированность (однозначное решение)
- понятность (все команды доступны)
- завершаемость (конечность)
- массовость (для разных задач)
- корректность (верно для всех задач)
- эффективность (быстро по времени)

Каждая структура данных реализует набор функций интерфейса (для операций над структурой).

#### Абстрактный тип данных (АТД)
**Математическая модель** данных и операции, определенных для этих данных. АТД выбирате заданную структуру данных и операции над ней. АТД - класс в ООП.

- операции над элементами этого типа
- данные относительно которых выполняются операции (значения)

Абстракция сводит всё к нужным деталям, ненужные выкидываются (скрывает свою внутреннюю реализацию)
<br>
Определяем **интерфейс** - операции над данными

- инкапсуляция деталей реализации (интерфейс можно оставить одинаковый, но внутри менять и улучшать его)
- снижение сложности (что может делать, а не как делать)
- ограничение области использования данных (данные не зависимы)
- высокая информативность интерфейса

**Класс = АТД + Наследование + Полиморфизм**
- Инкапсуляция - сокрытие поведения объекта внутри него (интерфейс)
- Наследование - один объект приобретает свойства другого
- Полиморфизм - различная реализация

### 9. Определение стека. Основные операции над стеком.
**Стек** - абстрактная структура данных, упорядоченный набор данных (как массив), но доступен только последний элемент.
<br>
«последним пришел – первым ушел» и часто называется структурой LIFO (Last In – First Out).

- перебор узлов дерева
- поиск вершин графа
- обход графа
- микропроцессоры
- старые калькуляторы
- веб браузер
- текстовые/графические редакторы

![image](https://github.com/mireashik/aood_3sem/assets/49165758/a896235b-e131-4899-a36c-92d38c5952d3)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/5b21f76b-ba68-4f82-9040-3c4c430876be)

### 10. Реализация стека и основных операций над стеком.
- push(S,x) - объект x в вершину стека
- pop(S) - удаляет объект из стека
- size(S) - число объектов
- isEmpty(S) - проверяет что стек пуст
- topValue(S) - возвращение верхнего объекта, не удаляя его

#### Стек - массив
![image](https://github.com/mireashik/aood_3sem/assets/49165758/b273ebce-3120-499c-8fd4-f6b88250ca65)

Эффективная реализация - массив, для хранения элементов стека.
<br>
Вершина стека (последний элемент) - переменная t
<br>
Недостаток - фиксированный размер.
