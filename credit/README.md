### 1 Структура данных (определение, назначение). Классификация структур данных. Характеристики.
**Структура данных (определение, назначение):**

Структура данных представляет собой организацию и хранение данных в компьютере таким образом, чтобы к ним можно было эффективно обращаться и выполнять различные операции. Она определяет способ организации и взаимосвязи между элементами данных, а также операции, которые можно выполнять с этими данными.

**Назначение структур данных:**

- **Эффективность:** Оптимизация использования памяти и времени выполнения операций.
- **Организация данных:** Позволяет группировать данные по определенным правилам для удобства и эффективности работы программы.
- **Облегчение алгоритмов:** Структуры данных предоставляют эффективные способы организации данных, что упрощает реализацию и оптимизацию алгоритмов.

**Классификация структур данных:**

1. **Линейные структуры данных:**
   - **Списки (List):** Упорядоченный набор элементов.
   - **Стек (Stack):** Структура данных с принципом Last In, First Out (LIFO).
   - **Очередь (Queue):** Структура данных с принципом First In, First Out (FIFO).

2. **Нелинейные структуры данных:**
   - **Граф (Graph):** Сеть связанных узлов (вершин) и ребер, описывающих отношения между ними.
   - **Дерево (Tree):** Структура данных, состоящая из узлов, связанных ребрами, при этом каждый узел имеет ровно одного родителя (за исключением корня) и может иметь несколько детей.

3. **Табличные структуры данных:**
   - **Массив (Array):** Упорядоченная коллекция элементов, доступ к которым осуществляется по индексу.
   - **Матрица (Matrix):** Двумерный массив, представляющий собой таблицу с элементами, расположенными в строках и столбцах.

**Характеристики структур данных:**

1. **Эффективность по времени:** Время, необходимое для выполнения операций (вставка, удаление, поиск и т. д.).
2. **Эффективность по памяти:** Использование ресурсов памяти для хранения данных и связанных структур.
3. **Простота использования:** Удобство работы с данной структурой данных в контексте конкретной задачи.
4. **Гибкость:** Возможность приспособления к различным сценариям использования.

### 2. Массивы: определение, классификация и основные поддерживаемые методы. Реализация поддерживаемых методов.
**Массив** - структура данных, состоящую из элементов 1 типа, расположенных в памяти последовательно и доступных по индексам. Элементы массива имеют одинаковый размер.

**Классификация:**

1. **Одномерные массивы (One-dimensional arrays):** Список элементов, расположенных в одном ряду. Доступ к элементам осуществляется по одному индексу.
2. **Двумерные массивы (Two-dimensional arrays):** Таблица элементов, разбитая на строки и столбцы. Доступ к элементам осуществляется по двум индексам (строка и столбец).
3. **Многомерные массивы (Multidimensional arrays):** Массивы с более чем двумя измерениями.

**Основные поддерживаемые методы:**
1. **Инициализация массива:** Создание массива и заполнение его элементами.
2. **Чтение элемента по индексу:** Получение значения элемента по указанному индексу.
3. **Запись элемента по индексу:** Установка значения элемента по указанному индексу.
4. **Поиск элемента:** Поиск элемента в массиве и возвращение его индекса.
5. **Добавление элемента:** Добавление нового элемента в массив.
6. **Удаление элемента:** Удаление элемента из массива.

### 3. Вектор: определение и основные поддерживаемые методы. Реализация поддерживаемых методов.
**Вектор: определение и основные поддерживаемые методы**

Вектор - упорядоченный набор элементов, которые могут использоваться для представления различных величин, например, координат точек в пространстве. Векторы могут быть одномерными (скаляры) или многомерными.

**Основные поддерживаемые методы:**
1. **Инициализация вектора:** Создание вектора и заполнение его элементами.
2. **Доступ к элементам вектора:** Получение значения элемента по индексу.
3. **Запись элементов вектора:** Установка значения элемента по указанному индексу.
4. **Сложение векторов:** Покомпонентное сложение элементов двух векторов.
5. **Умножение вектора на число:** Умножение каждого элемента вектора на заданное число.
6. **Скалярное произведение векторов:** Сумма произведений соответствующих элементов двух векторов.

### 4. Связной список. Операции над списками.
Связный список - структура данных, каждый элемент содержит информацию о следующем элементе. По сравнению с массивом - эффективное изменения расположения элементов. Хуже доступ к элементу списка (надо проходить по всему списку от начала)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/35ee6aee-c277-404e-a559-667ebe9b677c)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/c97e91f9-1e05-4446-9427-39963d32e447)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/91b93261-1085-438c-9e34-0858fc4ecd0a)

### 5. Реализация связных списков и основных операций над ними с помощью массива.
![image](https://github.com/mireashik/aood_3sem/assets/49165758/2a604421-4164-4ba2-8fda-7f6a16ee432b)

2 массива
<br>
В массиве **info** хранятся элементы множества
<br>
В массиве **next** указатели, индексы позиций в массивах, где расположены последующие элементы.

Вместо нескольких массивов, можно использовать 1 массив:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/a7bceb2e-79ca-4aad-986e-79e61092d122)

### 6. Реализация связных списков и основных операций над ними с помощью указателя.
Список состоит из ячеек и указателя, на следующую ячейку списка

![image](https://github.com/mireashik/aood_3sem/assets/49165758/96519e5c-fc33-4d75-9851-13b27ff1d015)

### 7. Классификация связных списков.
**Линейный список**

![image](https://github.com/mireashik/aood_3sem/assets/49165758/77949f6d-af6a-4e37-ada5-af1cfae02e8c)

**Линейный односвязный список**

![image](https://github.com/mireashik/aood_3sem/assets/49165758/d3164e58-ddec-4d10-b12b-5c08f6f926dd)

**Связный список с заголовками **(фиктивный элемент в начале)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/1493c1eb-7aa4-4f45-b6cd-20b7d668015c)

Упрощение включения и исключения

**Линейный двусвязный список**
![image](https://github.com/mireashik/aood_3sem/assets/49165758/44c58ae4-1ee0-46d4-bc37-66abbfa09be7)

**Циклический список**
![image](https://github.com/mireashik/aood_3sem/assets/49165758/3797cab1-fc32-43c6-8de3-32b7dd458938)

**Односвязный циклический список**
![image](https://github.com/mireashik/aood_3sem/assets/49165758/5e745dd8-edef-42e3-9049-b51a58f0b948)

**Двусвязный циклический список**
![image](https://github.com/mireashik/aood_3sem/assets/49165758/e187bb24-8148-4597-ba3a-4077b3c70454)

### 8. Алгоритмы и абстрактный тип данных.
**Алгоритм** – конечный набор правил, последовательность операций для решения задачи.

Частичный алгоритм - для некоторых d ∈ D, полный алгоритм - для всех d ∈ D

#### Формальные свойства алгоритмов
- полезность (умение решать)
- дискретность (последовательность решения)
- детерменированность (однозначное решение)
- понятность (все команды доступны)
- завершаемость (конечность)
- массовость (для разных задач)
- корректность (верно для всех задач)
- эффективность (быстро по времени)

Каждая структура данных реализует набор функций интерфейса (для операций над структурой).

#### Абстрактный тип данных (АТД)
**Математическая модель** данных и операции, определенных для этих данных. АТД выбирате заданную структуру данных и операции над ней. АТД - класс в ООП.

- операции над элементами этого типа
- данные относительно которых выполняются операции (значения)

Абстракция сводит всё к нужным деталям, ненужные выкидываются (скрывает свою внутреннюю реализацию)
<br>
Определяем **интерфейс** - операции над данными

- инкапсуляция деталей реализации (интерфейс можно оставить одинаковый, но внутри менять и улучшать его)
- снижение сложности (что может делать, а не как делать)
- ограничение области использования данных (данные не зависимы)
- высокая информативность интерфейса

**Класс = АТД + Наследование + Полиморфизм**
- Инкапсуляция - сокрытие поведения объекта внутри него (интерфейс)
- Наследование - один объект приобретает свойства другого
- Полиморфизм - различная реализация

### 9. Определение стека. Основные операции над стеком.
**Стек** - абстрактная структура данных, упорядоченный набор данных (как массив), но доступен только последний элемент.
<br>
«последним пришел – первым ушел» и часто называется структурой **LIFO** (Last In – First Out).

- перебор узлов дерева
- поиск вершин графа
- обход графа
- микропроцессоры
- старые калькуляторы
- веб браузер
- текстовые/графические редакторы

![image](https://github.com/mireashik/aood_3sem/assets/49165758/a896235b-e131-4899-a36c-92d38c5952d3)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/5b21f76b-ba68-4f82-9040-3c4c430876be)

### 10. Реализация стека и основных операций над стеком.
- push(S,x) - объект x в вершину стека
- pop(S) - удаляет объект из стека
- size(S) - число объектов
- isEmpty(S) - проверяет что стек пуст
- topValue(S) - возвращение верхнего объекта, не удаляя его

#### Стек - массив
![image](https://github.com/mireashik/aood_3sem/assets/49165758/b273ebce-3120-499c-8fd4-f6b88250ca65)

Эффективная реализация - массив, для хранения элементов стека.
<br>
Вершина стека (последний элемент) - переменная t
<br>
Недостаток - фиксированный размер (связное динамическое распределение решает эту проблему)

#### Стек - односвязный список
![image](https://github.com/mireashik/aood_3sem/assets/49165758/7f522323-4ece-4977-a038-429a4fd2fd01)

- При добавлении в стек нового элемента $е$ создается новый узел $v$, из $v$ устанавливается ссылка на $е$, и $v$ добавляется в начало списка.
- При извлечении элемента из стека узел удаляется из начала списка и возвращается его элемент.

### 11. Определение очереди. Операции над очередью.
Очередь - противоположность стека. Динамическая АТД
<br>
«первым пришел – первым ушел» и часто называется структурой **FIFO** (First In – First Out).

![image](https://github.com/mireashik/aood_3sem/assets/49165758/8d181f66-b470-4032-bafd-0c078bfde956)

- enqueue (Q, v) - помещает v в конец очереди
- dequeue (Q) - удаление и возвращение объекта из начала очереди
- size(Q) - число объектов
- isEmpty(Q) - проверяет что очередь пуста
- front(Q) - возвращение первого объекта (голову), не удаляя его
- Rear Value(Q) - возвращение последнего объекта (хвоста), не удаляя его
- Clear(Q) - очистка очереди
- TraverseQueue(Q) - просмотр очереди

#### Общие вопросы реализации очередей
- На основе массива (следим за началом и концом!).
- И головной, и хвостовой индексы всегда увеличиваются, но никогда не уменьшаются
- Кольцо (неэффективное использование памяти возможно преодолеть)

Змея может ползти бесконечно, оставаясь внутри кольца.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/0b4f83d7-0367-4b8a-a0fe-62eede72fe80)

Индексы использовать нельзя, чтобы отличить пустую очередь от полной.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/5a2380f6-d551-4846-9745-a08f7a1ba361)

- Кольцевой массив с одной пустой позицией **NULL**
- Кольцевой массив с булевой функцией (**true /false** - полна или нет?)
- Кольцевой массив с целочисленной переменной **-1000000**

### 12. Реализация очереди и основных операций над очередью.
#### Очередь - массив
Первая ячейка следует за последней (кольцо)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/999a32ce-a594-4b70-b586-ff4152d8823a)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/512f5446-e26b-46e1-96ef-37da79a715cf)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/21899016-91a6-4af1-abd9-6755ef504502)

Чтобы избежать переполнение "змеи" используем операцию модуля.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/646a53bf-1c8a-411f-a08f-8c5269f5d7b7)

#### Очередь - односвязный список
Процедура INSERT производится всегда в **конец** связного списка.

Реализация очереди упрощается, если использовать для ее представления **связный список с заголовком**, поскольку в этом случае нет необходимости в выявлении особых случаев.

### 13. Инфиксные, префиксные и постфиксные формы представления выражений.
- Инфиксные формы (типа B * C), оператор находится между 2 операндами.

В примере типа A + B * C проблема - нужно ввести приоритет.

- Префиксные формы (типа +A B) операторы перед значениями с которыми работают.
- Постфискые формы (типа A B +) операторы после значений.

Скобки в этих 2 формах не нужны!

![image](https://github.com/mireashik/aood_3sem/assets/49165758/7ba4e6a1-0538-4f59-be26-1befc4d8a068)


### 14. Преобразование инфиксного выражения в префиксное и постфиксное
![image](https://github.com/mireashik/aood_3sem/assets/49165758/49829c5b-5ad2-4d14-b13a-85715158af85)

Полная расстановка скобок поможет нам преобразовать. Оператор передвигается на крайнюю левую или крайнюю правую позицию.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/02643ac9-83b0-4769-9174-6f5a9e2e4853)

### 15. Обобщённое преобразование из инфиксного в постфиксный и префиксный виды

Храник операторы в стеке. На вершине - последний сохранённый оператор.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/bf60fe8a-7174-4bf8-8231-5a55a9b80b25)

Если нужно посчитать выражения, то используем стек и сканируем операнды. 

![image](https://github.com/mireashik/aood_3sem/assets/49165758/df504ba0-bdb0-47a3-abe3-ef118e21b8c2)

Однако нужно быть осторожным с делением (ибо 15 / 5 это не тоже самое что 5 / 15), операнды должны выталкиваться в **обратной** последовательности (не как в стеке, а как в очереди!)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/ed6b5abc-a458-4407-8c47-72ae95559984)

### 16. Кольцевая очередь. Базовые операции, выполняемые над кольцевыми очередями
Кольцевая очередь - первый элемент **не удаляется** и не выходит, он переходит в конец очереди.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/8a118067-4452-4d85-8e97-8407a8d165ca)

- добавить новый элемент в очередь;
- проверка, очереди на пустоту;
- проверка, очередь на полноту;
- очистка очереди (удаление всех элементов очереди);
- вытянуть 1 элемент из очереди и поместить в конец очереди.

### 17. Очередь с приоритетным включением
Очередь с приоритетом (каждый элемент имеет свой приоритет), можно создать:

- массив
- односвязный список

![image](https://github.com/mireashik/aood_3sem/assets/49165758/53371224-1e4d-49d1-9fd2-78c4d8e29d01)

- Упорядочены в момент **ВХОДА (включения)** (хранятся по приоритету)
- выходят в обычном порядке.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/ed6915ca-3187-4668-b309-e7e668ed1fec)

### 18. Очередь с приоритетным исключением

- В момент входа просто добавляются (в порядке поступления)
- ВЫХОДЯТ по приоритету

![image](https://github.com/mireashik/aood_3sem/assets/49165758/a65e1cdd-acdf-4cde-aed2-ee926283749d)

### 19. Деки: определение и операции над деком
Дек - список, одновременно работает по 2 принципам FIFO и LIFO. Это очередь с 2 сторонами, или стек с 2 концами.
<br>
Двухсторонний доступ, возможность выбора одной из его сторон

![image](https://github.com/mireashik/aood_3sem/assets/49165758/d41c0432-80c7-45ce-b139-c49415d4dd38)
