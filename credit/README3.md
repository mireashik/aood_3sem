### 56. Сортировка: общие понятия определения. Классификация алгоритмов сортировки. Оценка сортировки.
мы должны хранить ее в каком-то разумном порядке. Библиотекари следят за тем, чтобы никто не перекладывал книги. Кредитные организации следят за каждым нашим шагом.
<br>
Имена потребуется отсортировать по алфавиту, студентов ‒ по среднему баллу, клиентов ‒ по регионам, данные о продажах ‒ по ценам, города ‒ по населению, страны ‒ по ВВП и т.д

Мы рассмотрим алгоритмы, относящиеся к ПРОСТОЙ СОРТИРОВКЕ.
<br>
Далее мы рассмотрим алгоритмы УЛУЧШЕННОЙ СОРТИРОВКИ, или, алгоритмы сложной сортировки, как нередко их называют

Простые алгоритмы, работают относительно медленно и все же их стоит изучить.
<br>
Сортировка **методом вставки** превосходит **быструю сортировку** для небольших и почти отсортированных файлов

![image](https://github.com/mireashik/aood_3sem/assets/49165758/ace4dc1c-eacd-4f63-8933-32bf5c798704)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/18b68d01-5eec-49ab-acc9-39a0581a79bf)

1. Сравнить два элемента.
2. Поменять элементы местами или скопировать один из них.

Цель сортировки ‒ облегчение последующего поиска элементов в отсортированном множестве во внутренней или внешней памяти. 

Одно из полей, называемое КЛЮЧОМ, имеет такой тип данных, что на нем определено отношение линейного порядка «<».

**Алгоритмы внутренней сортировки** (сортировки массивов) предназначены для  работы с данными, которые **полностью** помещаются в оперативную память  вычислительной машины, выполняющей данную операцию. 
<br>
Важна экономичность по памяти

![image](https://github.com/mireashik/aood_3sem/assets/49165758/32df0c33-d708-4fc7-9395-4d606e4bb952)

**Алгоритмы внешней сортировки** (сортировки файлов) предназначены для работы с данными, объем которых **не позволяет** полностью разместить их в оперативной памяти вычислительной машины, выполняющей данную операцию (диски и магнитные ленты)

Основной метод сортировки – слияние.

- доступ к носителю осуществляется **последовательным** образом
- в каждый момент времени можно считать или записать только **1 элемент**
- доступ к данным на носителе производится намного **медленнее**, чем с ОЗУ

В зависимости от структуры:
- массива
- связного списка
- дерева (пирамиды)
- графа

Как структура меняется:
- сортировка списка (если элементы перемещаются)
- сортировка таблицы адресов (если элементы не перемещаются, таблица адресов)

Функциональные особенности:
- сортировка перестановками (обменная) – пузырьковая сортировка
- сортировка выбором (отбором)
- сортировка вставками
- сортировка подсчетом
- сортировка слиянием
- распределяющая сортировка

По широте применения:
- универсальные (большинство перечисленных выше групп алгоритмов)
- не универсальные (для конкретных случаев)

По перестановки совпадающих данных:
- УСТОЙЧИВЫМИ (не меняющие порядок)
- НЕУСТОЙЧИВЫЕ (меняющие порядок)

По времени работы:
- $O(N^2)$ - N-квадратичные
- $O(N^k)$ - где 1<k<2, алгоритм Шелла, если $k=3$ - глупая сортировка
- $O(log_2N)$ − логарифмические (быстрая сортировка, сортировка слиянием и пирамидальная сортировка)
- $O(N)$ – алгоритмы, требующие линейного времени, например, «блинная» сортировка

Возможны также некоторые другие принципы разделения алгоритмов сортировки, в том числе по занимаемой дополнительной памяти.

Оценка алгоритмов сортировки производится по следующим параметрам:
- ВРЕМЯ СОРТИРОВКИ
- количество шагов алгоритма
- количество сравнений между значениями ключей
- ПАМЯТЬ
- УСТОЙЧИВОСТЬ
- ЕСТЕСТВЕННОСТЬ ПОВЕДЕНИЯ (при уже отсортированных или частично отсортированных данных)

- ЛУЧШИЙ случай − это ситуация, когда структура данных уже **отсортирована** в нужном порядке.
- ХУДШИЙ случай – структура данных отсортирована в порядке, обратном  требуемому.

### 57. Задача сортировки. Пузырьковая сортировка. Сортировка вставками.
![image](https://github.com/mireashik/aood_3sem/assets/49165758/91c255f9-2ef9-4a97-8176-d78b82d19293)

Пусть ключом будет число жителей. Мы можем упорядочить эту последовательность несколькими способами, так как у нас есть одинаковые ключи. 

Алгоритм сортировки **устойчивый**, если он сохраняет относительный порядок элементов с одинаковыми ключами (при наличии одинаковых ключей)

#### Пузырьковая сортировка
Сортировка пузырьком (обменная сортировка) – простой в реализации и малоэффективный алгоритм сортировки.
<br>
Повторяющиеся проходы

![gif](https://habrastorage.org/getpro/habr/post_images/187/5a3/929/1875a3929dd14c8ea5ff4ccc3d0db9bd.gif)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/80776314-44e0-4791-9e4c-6dc070e31144)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/dc5eac88-ecb7-4421-8a1c-e796066fa449)

Сложность алгоритма посчитать также нетрудно. Так как один проход по массиву имеет сложность O(N), установить, что массив уже отсортирован, быстрее невозможно, поэтому в ЛУЧШЕМ случае сложность составляет именно O(N)

#### Пузырьковая сортировка: инвариант
![image](https://github.com/mireashik/aood_3sem/assets/49165758/a35c39ab-345c-4479-a76e-c8ba627a3edd)

Самый тяжёлый из ещё не обработанных элементов, подобно пузырьку, «всплывает» на свою позицию

#### Сортировка пузырьком: особенности
При пузырьковой сортировке сравниваются соседние элементы и меняются местами, если следующий элемент меньше предыдущего. Требуется несколько проходов по данным.

#### Сортировка вставками
![image](https://github.com/mireashik/aood_3sem/assets/49165758/c74694cd-908d-48fb-b3fa-8a5250684f4d)

После i-го прохода по массиву в первых i позициях будут находиться отсортированные i элементов первоначального массива.

#### Сортировка вставками: особенности
![image](https://github.com/mireashik/aood_3sem/assets/49165758/9d8b1734-f08c-49aa-a6f5-0d09b34b724c)

### 58. Задача сортировки. Сортировка Шелла. Сортировка выбором
#### Сортировка Шелла
Но почему обязательно нужно обменивать местами только соседние элементы? Может быть, попробовать обменивать элементы с расстоянием $d > 1$?

![image](https://github.com/mireashik/aood_3sem/assets/49165758/5c0603f5-2aac-4a24-85f5-96740fe53f5d)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/947b978c-6468-4aba-9b8d-d34b9933dbc8)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/5fb80d23-d766-4cfb-8f0a-ffccdf11b364)

Сам Шелл предложил выбирать шаги сортировки в виде убывающей геометрической прогрессии с шагами $N/2 , N/4 , . . . , 1$

![image](https://github.com/mireashik/aood_3sem/assets/49165758/486fec3c-6552-4d4c-a1ad-9c306ad8ebbe)

В первых строках выбирается начальный шаг, который затем уменьшается по приведённому закону.

#### Сортировка Шелла: особенности
![image](https://github.com/mireashik/aood_3sem/assets/49165758/169b4e62-2797-4abe-a50d-5eeae63a3127)

### Сортировка выбором
А почему бы не уменьшить количество обменов элементов между собой?

![image](https://github.com/mireashik/aood_3sem/assets/49165758/60141c09-0a8a-492d-84d0-08cc41b140d3)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/f7e61d37-cb5b-438a-9ff5-ebd32f5d6acf)

### 59. Нахождение k-й порядковой статистики.
k-й порядковой статистикой массива называется k-й по упорядочиванию величины элемент массива

Минимальный элемент массива ‒ 1-я
<br>
Максимальный элемент - порядковая статистика N

Пусть нужно найти $k = 6$ порядковую статистику в массиве:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/8410ad28-6786-4325-a99e-5c691740c224)

Пусть рулетка выпала на элемент со значением «элемент 8»

Разбиваем на 3 массива:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/874a1e3f-ccd3-4f33-b111-b44e95be4051)

Очевидно, что искомое находится в первом множестве; $k < |S_1|$ → первый случай.

Проделаем 2 итерацию:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/87ae0e93-6b34-458b-9f07-5dadbcb8ea42)

Пусть случайным образом выбран элемент 5:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/24fc480c-33c0-4063-a3b1-17719f904a21)

Выбран произвольный элемент 6:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/8c558d92-c795-4d78-a7cc-6fbe464ce1d9)

#### Нахождение k-статистики. Сложность
Алгоритм относится к классу алгоритмов разделяй и властвуй

Таким образом, у нас появился алгоритм, который в среднем способен находить k-ю порядковую статистику за время $O(N)$, или, как говорят, за линейное время, но в маловероятных худших случаях его сложность может составлять $O(N^2)$

### 60. Задача сортировки. Быстрая сортировка. Сортировка слиянием.
#### Быстрая сортировка
Почти повторяет алгоритм поиска k-й порядковой статистики.
<br>
 В его основе лежит -разбиение массива ведущим элементом на 2 подмассива ‒ и рекурсивная сортировка левой и правой частей. 

![image](https://github.com/mireashik/aood_3sem/assets/49165758/b9727b06-3794-4b39-8c03-86cbe1505cc1)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/55963edd-930e-465c-9df7-a602318bd2de)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/ebc7bdb2-e5b5-426d-b635-b3cfa40ac002)

И левая, и правая части нового массива, в конце концов, оказались достаточно малы для того, чтобы избежать рекурсии. Пусть в нашем примере такая граница проходит для массивов длиной 5 или меньших. На этом этапе в качестве «обычной» сортировки популярен алгоритм с**ортировки обменом**:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/9c173df7-2d61-4fd1-9280-9ef3e20f5339)

$S_{1r}$ после обычной сортировки станет равным $S_{1r}$ ={10, 13, 14, 18} Так как и левая, и правая части массива на каждом из этапов сортируются на месте (а ведущий элемент на месте уже находился), то массив оказывается отсортирован.

#### Быстрая сортировка: сложность
На практике один из простых способов ‒ выбрать медианный элемент из трёх случайных элементов массива.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/5f257d56-1228-44a0-9c0a-b8efd40f185a)

#### Сортировка слиянием
Алгоритмы нахождения k-статистики и быстрой сортировки основаны на операции выборки ‒ нахождения k-го минимального элемента в массиве. 
<br>
Но можно объединять уже отсортированные массивы

![image](https://github.com/mireashik/aood_3sem/assets/49165758/0f09ca25-1428-4feb-a3c7-bf38f5245168)

Установив порог перехода на обычную сортировку в 3 элемента:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/84822d44-b8f8-483a-9682-3479ce781e90)

#### Сортировка слиянием: сложность
В данном алгоритме мы наблюдаем классический пример работы принципа разделяй и властвуй ‒ обработка различных частей массива совершенно независима, следовательно, работает основная теорема о рекурсии

![image](https://github.com/mireashik/aood_3sem/assets/49165758/16b9a999-dc1d-4c28-bbe5-4117dd8b6ecc)

Интересный и полезный факт: **сложность не зависит от входных данных** и всегда равна O(N log N) 10 .

Прекрасно подходит для внешней сортировки, то есть сортировки файлов.

### 61. Задача сортировки. Пирамидальная сортировка.
Пирамидальная сортировка ‒ это алгоритм сортировки, в котором используется такая структура данных, как двоичная куча
<br>
неустойчивый алгоритм сортировки с временем работы O(NlogN)
<br>
использующий O(1) дополнительной памяти

**Законченное двоичное дерево** ‒ это двоичное дерево, в котором каждый уровень, за исключением, возможно, последнего, имеет полный набор узлов, и все листья расположены как можно левее

![image](https://github.com/mireashik/aood_3sem/assets/49165758/b95fd50c-0fdb-4293-b652-5d3c14d8f549)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/f94f7028-f6da-4b8a-af6b-7ab0815c7e26)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/55561b7a-8582-46de-9d53-becc03e595e0)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/43add3e4-b74b-4027-87e8-a12e724f47e1)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/823f398a-21eb-4753-b1f0-c5c6e838feaa)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/868c4bec-fc05-4329-96e3-e97767f6b240)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/73e411c5-69e0-4235-8a00-918f54d0cc23)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/8eefbd13-0d61-4704-84f5-aa13c10aaee8)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/fe886153-ece9-45e6-ac9f-a32a32d5e1d7)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/846499d3-304d-4bab-8b09-70f4af37e2a6)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/771cf7f9-23d7-449b-9f77-eb0e0f02a9a2)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/fa8ac42e-b04b-4116-b259-1d3b3110d131)

### 62. Задача сортировки. Сортировка TimSort.
Сортировка Timsort (двоичное дерево) ‒ гибридный алгоритм сортировки, который сочетает в себе два алгоритма сортировки: сортировку вставками и сортировку слиянием

1. По специальному алгоритму разделяем входной массив на подмассивы.
2. Сортируем каждый подмассив обычной сортировкой вставками.
3. Собираем отсортированные подмассивы в единый массив с помощью модифицированной сортировки слиянием.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/8b63ae59-b2f7-498d-80aa-a512c73e5ec5)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/df5f6d98-fe8f-45ee-921e-069ed130282a)

Тим Петерс, ссылаясь на собственные эксперименты. показавшие, что $minrun > 256$ нарушается 1 пункт, а при $minrun < 8$ 2 пункт
<br>
если $N < 64$, тогда $N = minrun$ и алгоритм Timsort становится сортировкой вставками.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/47a4528d-edca-45d8-b58d-6ad97fb65f83)

Процедура слияния совершает обход и сравнение в зависимости от того, как расположены подмассивы. Таким образом, для реализации алгоритма необходимы процедуры обхода слева направо (если меньший массив находится слева) и справа налево (если меньший массив находится справа). На практике обычно ограничиваются первой процедурой и выбирают левый массив независимо от его размера ‒ это почти не влияет на скорость сортировки.

1. Создаётся временный массив в размере меньшего из соединяемых подмассивов.
2. Меньший из подмассивов копируется во временный массив.
3. Указатели текущей позиции ставятся на первые (последние) элементы большего и временного массива.
4. На каждом следующем шаге рассматривается значение текущих элементов в большем и временном массивах, берётся меньший (больший) из них и копируется в новый отсортированный массив. Указатель текущего элемента перемещается в массиве, из которого был взят элемент.
5. Пункт 4 повторяется, пока один из массивов не закончится.
6. Все элементы оставшегося массива добавляются в конец нового массива.

![image](https://github.com/mireashik/aood_3sem/assets/49165758/edb434cd-b1d2-4cc0-a2ff-e1318dd00e8c)

A = {1, 2, 3,..., 9999, 10000}
<br>
B = {20000, 20001, ...., 29999, 30000}

В алгоритме Timsort используется модифицированная процедура слияния. Данная модификация получила названия «галоп». 

![image](https://github.com/mireashik/aood_3sem/assets/49165758/eae2b16f-7a21-4b01-9ea2-f5ac2a93c2ec)

Первые 7 итераций сравниваются числа 1, 2, 3, 4, 5, 6 и 7 из массива A с числом 20000, так как 20000 больше ‒ элементы массива A копируются в результирующий
<br>
со следующей итерации алгоритм переходит в режим «галопа»: сравнивает с числом 20000 последовательно элементы 8, 10, 14, 22, 38, $n+2^i$, …, 10000 массива A. ($~log^2 N$ сравнений)

minrun принадлежит диапазону [32;65). Почему это так? 

![image](https://github.com/mireashik/aood_3sem/assets/49165758/b92bbce8-7183-4297-9238-e4de9197c75d)

**сливаемые** массивы ВСЕГДА имеют примерно одинаковую длину

O(logN) операций слияния, а значит и каждый элемент будет задействован в сравнениях не более O(logN) раз

![image](https://github.com/mireashik/aood_3sem/assets/49165758/93a6f14d-e464-4a2d-b34c-2091d54a9bea)

при большом minrun слияний будет меньше, а сортировки вставками будут выполняться долго
<br>
оптимальный диапазон ‒ от 32 до 64

### 63. Задача сортировки. Сортировка с помощью двоичного дерева.
Построение двоичного дерева поиска по ключам, далее обход узлов дерева в необходимом порядке ключей 

**Двоичное дерево поиска** ‒ двоичное дерево с доп. условиями:
- оба поддерева ‒ левое и правое ‒ являются двоичными деревьями поиска
- Левее X - меньше X
- Правее X - больше или равно X

![image](https://github.com/mireashik/aood_3sem/assets/49165758/123da9eb-baad-4b9b-b603-6af8a0617cfb)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/bf611388-bcb7-4705-8b13-c7b4b5a2e5db)

Построим двоичное дерево поиска:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/90e3f233-bb81-4a78-9f28-915faa00595f)

Далее инфиксная форму обхода (симметричном порядке, слева направо):

![image](https://github.com/mireashik/aood_3sem/assets/49165758/51a6e163-8d3d-45d0-a8c5-6871f821fa93)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/03e38452-5161-452a-b65a-317d41711701)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/e968eecb-98fc-4df5-af3d-2881614c1537)

Строим в том же порядке, но по правилам дерева:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/2ec8af5c-309e-4b9d-b03a-7ca47b936df5)

Если входная последовательность уже отсортирована, то дерево выродится в линейный список

Если мы будем рекурсивно обходить дерево по правилу: «левый сын ‒ родитель - правый сын» (а это и есть инфиксная форма обхода) ‒ то будет упорядоченный массив

![image](https://github.com/mireashik/aood_3sem/assets/49165758/c32a42db-94fe-4cfc-a6af-d804558b6b4a)

### 64. Сортировка со свойствами элементов: сортировка подсчётом.
Есть ли алгоритмы сортировки со сложностью, меньшей O(NlogN)? Да, если использовать свойства ключей, можно за O(N)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/9c217943-9161-4176-b528-0d79fc22c70b)

Вводим массив:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/c97b698b-5587-4c3a-a6a8-86eaa2f287ce)

Массив F - i элемент показывает количество элементов значением i из исходного массива S

![image](https://github.com/mireashik/aood_3sem/assets/49165758/7ef1ea5c-11c3-4107-80e1-da8de6577a31)

Далее просто собираем новый массив:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/e0e45f1f-dc8d-4957-b7b0-da387967e94a)

Мы не применяли операций сравнения. Из-за этого сравнивать можно только целые числа. 

#### Сортировка подсчётом: особенности
- Ключи должны быть перечислимы
- Требуется дополнительная память
- O(|D(K)|) + O(N)

## 65. Сортировка со свойствами элементов: поразрядная сортировка.
1 автоматизированная промышленная сортировка

перфокарты, карманы (линии), без использования операций сравнения 

![image](https://github.com/mireashik/aood_3sem/assets/49165758/b8daa6e2-783a-45a4-bcbd-cf1100b08c5a)

![image](https://github.com/mireashik/aood_3sem/assets/49165758/3d85e41b-143d-40c5-8500-b5244c2e7175)

По 3 разряду:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/2eccccd8-a394-46e4-9f9c-7e6050d18ad6)

По 2 разряду:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/82cec072-c2db-4d7d-b160-1e6094aa644b)

По 1 разряду:

![image](https://github.com/mireashik/aood_3sem/assets/49165758/b5b9adca-c2df-41f0-9b0e-806c9b3197bc)

3O(N)=O(N)

Стопку помещали в карман
<br>
После нажатия на кнопку - сортировка

Затем работник, не меняя порядка внутри перфокарт в кармане (устойчивая сортировка), собирал перфокарты в нужном порядке, получая тем самым частично отсортированную по ключу стопку
<br>
Затем переключатель устанавливался на предпоследнюю цифру ключа

- Требует ключи
- Требует дополнительной памяти
- Сложность постоянна

операция разделения числа на фрагменты  - медленная, быстрее использовать разделение на наборы битов или байтов

#### 1.5. Сравнительный анализ методов внутренней сортировки
![image](https://github.com/mireashik/aood_3sem/assets/49165758/a940bc9a-04fb-4b60-b984-1a4610ac1a3a)

